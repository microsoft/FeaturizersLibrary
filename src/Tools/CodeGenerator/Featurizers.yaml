featurizers:
  # ----------------------------------------------------------------------
  - name: AnalyticalRollingWindowFeaturizer
    estimator_name: GrainedAnalyticalRollingWindowEstimator
    release_version: 0.4.0
    num_output_columns: 1
    transformer_maintains_state: true
    creates_annotations: false
    description: |-
        Calculates data based on a rolling window. Currently supports mean. Works for any data set that is already sorted.

        Input type for this featurizer is a tuple of the grain columns and target value column. It is assumed that the data is sorted in the correct order.

        C++-style pseudo signature:
        template <typename T> matrix<double> execute(std::tuple<std::vector<std::string> const &, T const &> value);

        Examples:
            A simple example would be horizon = 1, maxWindowSize = 2, and we want to take the mean.

            +-----------+-------+-------------------+
            | grain     | target| target_mean       |
            +===========+=======+===================+
            | A         | 10    | [[NAN]]           |
            +-----------+-------+-------------------+
            | A         | 4     | [[10]]            |
            +-----------+-------+-------------------+
            | A         | 6     | [[7]]             |
            +-----------+-------+-------------------+
            | A         | 11    | [[5]]             |
            +-----------+-------+-------------------+

            A more complex example would be, assuming we have horizon = 2, maxWindowSize = 2, min window size = 2, and we want the mean
            +-----------+-------+-------------------+
            | grain     | target| target_max        |
            +===========+=======+===================+
            | A         | 10    | [[NAN, NAN]]      |
            +-----------+-------+-------------------+
            | A         | 4     | [[NAN, NAN]]      |
            +-----------+-------+-------------------+
            | A         | 6     | [[NAN, 7]]        |
            +-----------+-------+-------------------+
            | A         | 11    | [[7, 5]]          |
            +-----------+-------+-------------------+

    templates:
      - name: T
        types:
          # Note that optional values during output increase quite a bit of overhead when marshalling, therefore
          # this featurizer only supports those types that don't have to pay that penality. We may still want to support
          # these types in the future in some frameworks.
          #
          # - int8
          # - int16
          # - int32
          # - int64
          # - uint8
          # - uint16
          # - uint32
          # - uint64
          - float
          - double

    type_mappings:
      - input_type: tuple<unique_id, T>
        output_type: matrix<double?>
        description: A matrix always of 1 row and column of size horizon, but the individual elements could be NaN.

    custom_enums:
      - name: AnalyticalRollingWindowCalculation
        description: What calculation to use on the rolling window.
        values: [Mean]
        underlying_type: uint8

    configuration_params:
      - type: AnalyticalRollingWindowCalculation
        name: windowCalculation
        description: What calculation is going to be performed over the window data.

      - type: uint32
        name: horizon
        description: The horizon value. The size of the output vector will be equal to this value.

      - type: uint32
        name: maxWindowSize
        description: The maximum number of items in a window.

      - type: uint32
        name: minWindowSize
        default_value: 1
        description: The minimum number of elements that must be in an window to perform the calculation. If there is less, NaN will be returned. Defaults to 1.

  # ----------------------------------------------------------------------
  - name: BackwardFillImputerFeaturizer
    estimator_name: BackwardFillImputerEstimator
    release_version: 0.4.0
    num_output_columns: 1
    creates_annotations: false
    transformer_maintains_state: true
    has_dynamic_output: true
    description: |-
      Imputes (populates) previously encountered null values with the current non-null value encountered during
      inference time.

      C++-style pseudo signature:
        float execute(float const &value);
        std::string execute(std::optional<std::string> const &value);

      Examples:
        execute(1.0) -> 1.0

        execute(NaN) -> 2.0  // Latest non-null value is 2.0
        execute(2.0) -> 2.0

        execute(3.0) -> 3.0

        execute(NaN) -> 4.0  // Last non-null value was 4.0
        execute(NaN) -> 4.0  // Last non-null value was 4.0
        execute(4.0) -> 4.0

        execute(NaN)
        flush() // Exception, as pending values remain

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T?
        output_type: T

  # ----------------------------------------------------------------------
  - name: CatImputerFeaturizer
    estimator_name: CatImputerEstimator

    release_version: 0.3.0
    deprecated_version: 0.3.6

    num_output_columns: 1
    description: |-
      *****
      *****

      This featurizer has been DEPRECATED in favor of the ModeImputerFeaturizer.

      *****
      *****

      Imputes (populates) values with the mode (most common value) encountered during
      training. This featurizer supports float and double for most (if not all) frameworks
      due to the existance of NaN in those types. Other types require 'optional' support
      within the host frameworks and programming languages.

      C++-style pseudo signature:
        float execute(float const &value);
        double execute(double const &value);
        template <typename T> T execute(std::optional<T> const &value);

      Examples (where 55.5 is the mode value):
        execute(1.0) -> 1.0
        execute(NaN) -> 55.5
        execute(2.0) -> 2.0

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T?
        output_type: T

  # ----------------------------------------------------------------------
  - name: CountVectorizerFeaturizer
    estimator_name: CountVectorizerEstimator
    release_version: 0.3.6
    num_output_columns: 1
    description: |-
      Returns the count of the number of occurrances of each distinct item according to a
      vocabulary established during training.

      C++-style pseudo signature:
        CountVector execute(std::string const &value);

      Examples:
        Assuming the training data is...
        ["orange apple orange grape", "grape carrot carrot apple", "peach banana orange banana"]

        The input data is...
        "banana grape grape apple apple apple orange"

        The result will be computed by...
          categorize and compute each word's number of appearance in input data, we have "apple -> 3", "banana -> 1", "grape -> 2", "orange -> 1"
          construct a dictionary and assign id for each unique word using training data, we have "apple -> 0", "banana -> 1", "grape -> 3", "orange -> 4"
          generate TFStruct by combining <word's id, word's number of appearance>

        The result is...
        [3, 1, 0, 2, 1]

    featurizer_is_a_template: true

    type_mappings:
      - input_type: string
        output_type: sparse_vector<uint32>

    custom_enums:
      - name: AnalyzerMethod
        description: Used by Text-based parsers to determine the granularity of tokens extracted transformation.
        values: [Word, Char, Charwb]
        underlying_type: uint8

    configuration_params:
      - type: bool
        name: lower

      - type: AnalyzerMethod
        name: analyzer

      - type: string
        name: regexToken

      - type: float
        name: maxDf

      - type: float
        name: minDf

      - type: uint32?
        name: topKTerms

      - type: uint32
        name: ngramRangeMin

      - type: uint32
        name: ngramRangeMax

      - type: bool
        name: binary

  # ----------------------------------------------------------------------
  - name: DateTimeFeaturizer
    estimator_name: DateTimeEstimator
    release_version: 0.3.6
    num_output_columns: 21
    creates_annotations: false
    description: |-
      Extracts various datetime-related values from a UTC time_point.

      C++-style pseudo signature:
        TimePoint execute(std::chrono::system_clock::time_point const &value);

      Examples:
        Given a time_point 'value' representing "November 17, 1976 12:27:04PM":

        "November 17, 1976 12:27:04PM" => {
          "year": 1976,
          "month": 11,
          "day": 17,
          "hour": 12,
          "minute": 27,
          "second": 04,
          "amPm": 2,        // PM
          "hour12": 12,
          "dayOfWeek": 3,   // Wednesday
          "dayOfQuarter": 48,
          "dayOfYear": 321,
          "weekOfMonth": 2,
          "quarterOfYear": 4,
          "halfOfYear": 2,
          "weekIso": 47,
          "yearIso": 1976,
          "monthLabel": "November",
          "amPmLabel": "pm",
          "dayOfWeekLabel": "Wednesday",
          "holidayName": "",
          "isPaidTimeOff": 0
        }

    type_mappings:
      - input_type: datetime
        output_type: TimePoint

    configuration_params:
      - type: string?
        name: optionalCountryName

      - type: string?
        name: optionalDataRootDir

    custom_structs:
      - name: TimePoint
        members:
          - type: int32
            name: year
          - type: uint8
            name: month
          - type: uint8
            name: day
          - type: uint8
            name: hour
          - type: uint8
            name: minute
          - type: uint8
            name: second
          - type: uint8
            name: amPm
          - type: uint8
            name: hour12
          - type: uint8
            name: dayOfWeek
          - type: uint8
            name: dayOfQuarter
          - type: uint16
            name: dayOfYear
          - type: uint16
            name: weekOfMonth
          - type: uint8
            name: quarterOfYear
          - type: uint8
            name: halfOfYear
          - type: uint8
            name: weekIso
          - type: int32
            name: yearIso
          - type: string
            name: monthLabel
          - type: string
            name: amPmLabel
          - type: string
            name: dayOfWeekLabel
          - type: string
            name: holidayName
          - type: uint8
            name: isPaidTimeOff

  # ----------------------------------------------------------------------
  - name: ForecastingPivotFeaturizer
    estimator_name: ForecastingPivotEstimator
    release_version: 0.4.0
    num_output_columns: 1
    creates_annotations: false
    has_dynamic_output: true
    description: |-
        Similar to an Excel pivot table, this featurizer will expand values in the given output
        where all "linked" values are not null/empty. "linked" means that all values in the same
        column across all matrixes are not null/empty.

        All rows across all matrixes must have the same length / same number of columns. The maximum number
        of rows generated by each invocation is equal to the number of columns of all the input matrixes.

        Better explained through examples, see below for a more detailed explaination of the
        functionality.

        C++-style pseudo signature:
        std::vector<double> execute(std::vector<Eigen::Matrix<double>> const &);
        std::vector<std::optional<std::string>> execute(std::vector<Eigen::Matrix<std::optional<std::string>>> const &);

        Examples:
          Given results produced by the RollingWindow- and LagLead-Transformers...

          +-------+--------------------------------+--------------------------------+
          | Index |     Rolling Window Results     |        Lag Lead Results        |
          +=======+================================+================================+
          | 0     | [ [na, na, na] ]               | [ [na, na, na], [na, na, na] ] |
          +-------+--------------------------------+--------------------------------+
          | 1     | [ [1, 2, 3] ]                  | [ [na, na, na], [na, na, na] ] |
          +-------+--------------------------------+--------------------------------+
          | 2     | [ [1, 2, 3] ]                  | [ [na, na, na], [na, na, na] ] |
          +-------+--------------------------------+--------------------------------+
          | 3     | [ [1, 2, 3] ]                  | [ [A, B, C], [na, na, na] ]    |
          +-------+--------------------------------+--------------------------------+
          | 4     | [ [1, 2, 3] ]                  | [ [A, B, C], [D, na, na] ]     |
          +-------+--------------------------------+--------------------------------+
          | 5     | [ [1, 2, 3] ]                  | [ [A, B, C], [D, na, F] ]      |
          +-------+--------------------------------+--------------------------------+

          Results:

            4: 1, A, D
            5: 1, A, D
            5: 3, C, F

          A more thourough description below uses the following notation:

            RW: Rolling Window Results
            LL: Lag Lead Results

            RW[row_index][col_index]
            LL[row_index][col_index]

            Using this notation for input index 5, we see:

              RW[0][0] == 1       LL[0][0] == A
              RW[0][1] == 2       LL[0][1] == B
                                  LL[1][0] == D
                                  LL[1][1] == na
                                  LL[1][2] == F

            For input at index N:

              0:
                RW[0][0] == na, LL[0][0] == na, LL[1][0] == na;   na's found, nothing to output
                RW[0][1] == na, LL[0][1] == na, LL[1][1] == na;   na's found, nothing to output
                RW[0][2] == na, LL[0][2] == na, LL[1][2] == na;   na's found, nothing to output

              ...

              4:
                RW[0][0] == 1, LL[0][0] == A, LL[1][0] == D;      no na's found - OUTPUT GENERATED (1, A, D)
                RW[0][1] == 2, LL[0][1] == B, LL[1][1] == na;     na's found, nothing to output
                RW[0][2] == 3, LL[0][2] == C, LL[1][2] == na;     na's found, nothing to output

              5:
                RW[0][0] == 1, LL[0][0] == A, LL[1][0] == D;      no na's found - OUTPUT GENERATED (1, A, D)
                RW[0][1] == 2, LL[0][1] == B, LL[1][1] == na;     na's found, nothing to output
                RW[0][2] == 3, LL[0][2] == C, LL[1][2] == F;      no na's found - OUTPUT GENERATED (3, C, F)

    templates:
      - name: T
        types:
            # Note that optional values during output increase quite a bit of overhead when marshalling, therefore
            # this featurizer only supports those types that don't have to pay that penalty.
            #
            # - int8
            # - int16
            # - int32
            # - int64
            # - uint8
            # - uint16
            # - uint32
            # - uint64
            # - bool
            # - string
            - float
            - double

    type_mappings:
      - input_type: vector<matrix<T?>>
        output_type: vector<T>

  # ----------------------------------------------------------------------
  - name: ForwardFillImputerFeaturizer
    estimator_name: ForwardFillImputerEstimator
    release_version: 0.4.0
    num_output_columns: 1
    creates_annotations: false
    transformer_maintains_state: true

    description: |-
      Imputes (populates) values with the last non-null value encountered during
      inference time.

      C++-style pseudo signature:
        float execute(float const &value);
        std::string execute(std::optional<std::string> const &value);

      Examples:
        execute(NaN) // Exception, as a non-value value has not been encountered
        execute(1.0) -> 1.0
        execute(NaN) -> 1.0  // Last non-null value was 1.0
        execute(2.0) -> 2.0
        execute(3.0) -> 3.0
        execute(NaN) -> 3.0  // Last non-null value was 3.0
        execute(NaN) -> 3.0  // Last non-null value was 3.0
        execute(4.0) -> 4.0

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T?
        output_type: T

  # ----------------------------------------------------------------------
  - name: FromStringFeaturizer
    estimator_name: FromStringEstimator
    release_version: 0.3.6
    num_output_columns: 1
    creates_annotations: false
    description: |-
      Converts from a string to a scalar type.

      C++-style pseudo signature:
        int32 execute(std::string const &value);
        bool execute(std::string const &value);

      Examples:
        execute("True") -> true [bool]
        execute("10") -> 10 [int32]

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    is_input_a_template: false
    is_output_a_template: true

    type_mappings:
      - input_type: string
        output_type: T

    configuration_params:
      - type: bool
        name: useEmptyStringsForNullValues

  # ----------------------------------------------------------------------
  - name: HashOneHotVectorizerFeaturizer
    estimator_name: HashOneHotVectorizerEstimator
    release_version: 0.3.6
    num_output_columns: 1
    creates_annotations: false
    description: |-
      Hashes the input to a categorical value, then produces a one hot encoded vector
      based on that value.

      C++-style pseudo signature:
          template <typename T> HashOneHotVectorizerStruct execute(T const &value);

      Examples:
        Assuming the hashing algorithm...
          "A" -> 1
          "B" -> 2
          "C" -> 5

        and 'numCols' set to 8:

          execute("A") -> [1, 0, 0, 0, 0, 0, 0, 0]
          execute("B") -> [0, 1, 0, 0, 0, 0, 0, 0]
          execute("C") -> [0, 0, 0, 0, 1, 0, 0, 0]

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T
        output_type: single_value_sparse_vector<uint8>

    configuration_params:
      - type: uint32
        name: hashingSeedVal

      - type: uint32
        name: numCols

  # ----------------------------------------------------------------------
  - name: ImputationMarkerFeaturizer
    estimator_name: ImputationMarkerEstimator
    release_version: 0.3.6
    num_output_columns: 1
    creates_annotations: false
    description: |-
      Returns true if the input is null, false if it is not.

      C++-style pseudo signature:
        bool execute(float const &value);
        bool execute(double const &value);
        template <typename T> bool execute(std::optional<T> const &value);

      Examples:
        3.0 -> false
        NaN -> true
        "foo" -> false
        std::optional<string>() -> true
        std::optional<string>("bar") -> false

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T?
        output_type: bool

  # ----------------------------------------------------------------------
  - name: L1NormalizeFeaturizer
    estimator_name: L1NormalizeEstimator
    release_version: 0.3.6
    num_output_columns: 1
    description: |-
      Computes the L1 norm for a provided data set and normalize every row so that
      its L1 norm is 1

      C++-style pseudo signature:
        template <typename IteratorT> std::vector<std::double_t> execute(std::pair<IteratorT, IteratorT> const &value);
        template <typename IteratorT> std::vector<std::double_t> execute(std::tuple<IteratorT, IteratorT> const &value);

      Examples:
        Given the training data
        [[4, 1, 2, 2],
         [1, 3, 9, 3],
         [5, 7, 5, 1]]

         L1 norms for each row are: [9, 16, 18]

        execute([4,1,2,2]) = [4/9, 1/9, 2/9, 2/9]
        execute([1,3,9,3]) = [1/16, 3/16, 9/16, 3/16]

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double

    type_mappings:
      - input_type: vector<T>
        output_type: vector<double>

  # ----------------------------------------------------------------------
  - name: L2NormalizeFeaturizer
    estimator_name: L2NormalizeEstimator
    release_version: 0.3.6
    num_output_columns: 1
    description: |-
      Computes the L2 norm for a provided data set and normalize every row so that
      its L2 norm is 1

      C++-style pseudo signature:
        template <typename IteratorT> std::vector<std::double_t> execute(std::pair<IteratorT, IteratorT> const &value);
        template <typename IteratorT> std::vector<std::double_t> execute(std::tuple<IteratorT, IteratorT> const &value);

      Examples:
        Given the training data
        [[4, 1, 2, 2],
         [1, 3, 9, 3],
         [5, 7, 5, 1]]

         L2 norms for each row are: [5, 10, 10]

        execute([4,1,2,2]) = [4/5, 1/5, 2/5, 2/5]
        execute([1,3,9,3]) = [1/10, 3/10, 9/10, 3/10]

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double

    type_mappings:
      - input_type: vector<T>
        output_type: vector<double>

  # ----------------------------------------------------------------------
  - name: LabelEncoderFeaturizer
    estimator_name: LabelEncoderEstimator
    release_version: 0.3.6
    num_output_columns: 1
    description: |-
      Returns a unique id for the input based on all values encountered during training.

      C++-style pseudo signature:
        template <typename T> uint32 execute(T const &value);

      Examples:
        Assuming the training data of ["A", "B", "C"]...

        execute("A") -> 1
        execute("B") -> 2
        execute("C") -> 3
        execute("This value was not seen during training") -> 0

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T
        output_type: uint32

    configuration_params:
      - type: bool
        name: suppressUnrecognizedErrors

  # ----------------------------------------------------------------------
  - name: LagLeadOperatorFeaturizer
    estimator_name: GrainedLagLeadOperatorEstimator
    release_version: 0.4.0
    num_output_columns: 1
    has_dynamic_output: true
    transformer_maintains_state: true
    creates_annotations: false
    description: |-
      Copying values from prior or future per grain. Works for general time series data sets.

      The Horizon represents the maximum value in a range [1, N], where each element in that range is a delta applied to each offset. The resulting matrix will be in the form:

      [
      [value[offset[0] - N], value[offset[0] - (N - 1)], ..., value[offset[0] - 1]],
      [value[offset[1] - N], value[offset[1] - (N - 1)], ..., value[offset[1] - 1]],
      ...
      [value[offset[K - 1] - N], value[offset[K - 1] - (N - 1)], ..., value[offset[K - 1] - 1]]
      ]

      The resulting matrix size is K rows x N cols, where K is the number of offsets and N is the horizon.

      Horizon and offsets should be passed in during construction. Offsets are passed in as a vector of ints so multiple lag orders can be applied within one featurizer call.
      Output type is a tuple of vector of string, which representing grains, and a matrix. The matrix is of optional<T> where rows are grouped by different offsets and columns are grouped by horizon.

      C++-style pseudo signature:
        template <typename T> tuple<vector<string>,matrix<T?>> execute(std::vector<std::string> const &, T const &> const &value);

      Examples:
          Since this featurizer is copying values per grain, we just use one type of grain in the following examples.

          A simple example would be horizon = 1 and we have offsets as [-3, 1] (which means lag 3 and lead 1)
          +-------+-------+---------------------+
          | grain | target| target_lag_3_lead_1 |
          +=======+=======+=====================+
          |Walmart| 8     | [[NAN], [  9]]      |
          +-------+-------+---------------------+
          |Walmart| 9     | [[NAN], [ 10]]      |
          +-------+-------+---------------------+
          |Walmart| 10    | [[NAN], [ 11]]      |
          +-------+-------+---------------------+
          |Walmart| 11    | [[  8], [NAN]]      |
          +-------+-------+---------------------+
          Values from the row above current row are copied.

          A more complex example would be, assuming we have horizon = 2 and we have offsets as [-2, 2, 1, -1] (which means lag 2, lead 2, lead 1 and lag 1)
          +-------+-------+-------------------------------------------------+
          | grain | target|        target_lag_2_lead_2_lead_1_lag_1         |
          +=======+=======+=================================================+
          |Walmart| 8     | [[NAN, NAN], [  9,  10], [NAN, NAN], [ 8,   9]] |
          +-------+-------+-------------------------------------------------+
          |Walmart| 9     | [[NAN, NAN], [ 10,  11], [NAN,   8], [ 9,  10]] |
          +-------+-------+-------------------------------------------------+
          |Walmart| 10    | [[NAN,   8], [ 11, NAN], [  8,   9], [10,  11]] |
          +-------+-------+-------------------------------------------------+
          |Walmart| 11    | [[  8,   9], [NAN, NAN], [  9,  10], [11, NAN]] |
          +-------+-------+-------------------------------------------------+
          Basically, if we have an offset of k for the row with row index t,
          target_lag_k[t] = target[t - horizon + k + 1]

    templates:
      - name: T
        types:
          # Note that optional values during output increase quite a bit of overhead when marshalling, therefore
          # this featurizer only supports those types that don't have to pay that penalty.
          #
          # - int8
          # - int16
          # - int32
          # - int64
          # - uint8
          # - uint16
          # - uint32
          # - uint64
          # - string
          - float
          - double

    type_mappings:
      - input_type: tuple<unique_id, T>
        output_type: tuple<unique_id, matrix<T?>>

    configuration_params:
      - type: uint32
        name: horizon

      - type: vector<int64>
        name: deltas

  # ----------------------------------------------------------------------
  - name: MaxAbsScalerFeaturizer
    estimator_name: MaxAbsScalerEstimator
    release_version: 0.3.6
    num_output_columns: 1
    is_output_a_template: true
    description: |-
      Scales input based on the maximum absolute value of all data encountered during training.

      C++-style pseudo signature:
        float execute(uint16 value);
        double execute(uint32 value);

      Examples:
        Given a training set of [1.0, -2.0, 3.0, -4.0], where 4.0 is the absolute value of the
        maximum value encountered...

        execute(1.0) -> 1.0 / 4.0
        execute(-4.0) -> -4.0 / 4.0
        execute(100.0) -> 100 / 4.0

    templates:
      - name: TInputFloat
        types:
          - int8
          - int16
          - uint8
          - uint16
          - float

      - name: TInputDouble
        types:
          - int32
          - int64
          - uint32
          - uint64
          - double

    type_mappings:
      - input_type: TInputFloat
        output_type: float

      - input_type: TInputDouble
        output_type: double

  # ----------------------------------------------------------------------
  - name: MaxNormalizeFeaturizer
    estimator_name: MaxNormalizeEstimator
    release_version: 0.3.6
    num_output_columns: 1
    description: |-
      Computes the max norm for a provided data set and normalize every row so that
      its max norm is 1

      C++-style pseudo signature:
        template <typename IteratorT> std::vector<std::double_t> execute(std::pair<IteratorT, IteratorT> const &value);
        template <typename IteratorT> std::vector<std::double_t> execute(std::tuple<IteratorT, IteratorT> const &value);

      Examples:
        Given the training data
        [[4, 1, 2, 2],
         [1, 3, 9, 3],
         [5, 7, 5, 1]]

         Max norms for each row are: [4, 9, 7]

        execute([4,1,2,2]) = [4/4, 1/4, 2/4, 2/4]
        execute([1,3,9,3]) = [1/9, 3/9, 9/9, 3/9]

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double

    type_mappings:
      - input_type: vector<T>
        output_type: vector<double>

  # ----------------------------------------------------------------------
  - name: MeanImputerFeaturizer
    estimator_name: MeanImputerEstimator
    release_version: 0.3.6
    num_output_columns: 1
    description: |-
      Imputes (populates) values with the mean (average) value encountered during
      training.

      C++-style pseudo signature:
        float execute(float const &value);
        double execute(double const &value);
        template <typename T> T execute(std::optional<T> const &value);

      Examples (where 123.4 is the mean value):
        execute(1.0) -> 1.0
        execute(NaN) -> 123.4
        execute(2.0) -> 2.0

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double

    type_mappings:
      - input_type: T?
        output_type: double

  # ----------------------------------------------------------------------
  - name: MedianImputerFeaturizer
    estimator_name: MedianImputerEstimator
    release_version: 0.3.6
    num_output_columns: 1
    is_output_a_template: true
    description: |-
      Imputes (populates) values with the median value encountered during
      training.

      C++-style pseudo signature:
        float execute(float const &value);
        double execute(double const &value);
        template <typename T> T execute(std::optional<T> const &value);

      Examples (where 123.4 is the median value):
        execute(1.0) -> 1.0
        execute(NaN) -> 123.4
        execute(2.0) -> 2.0

    templates:
      - name: TIntegerOrNumeric
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double

      - name: TInputNoInterpolation
        types:
          - bool
          - string

    type_mappings:
      - input_type: TIntegerOrNumeric?
        output_type: double

      - input_type: TInputNoInterpolation?
        output_type: TInputNoInterpolation

  # ----------------------------------------------------------------------
  - name: MinMaxImputerFeaturizer
    estimator_name: MinMaxImputerEstimator
    release_version: 0.3.6
    num_output_columns: 1
    description: |-
      Imputes (populates) values with the minimum or maximum value encountered during
      training.

      C++-style pseudo signature:
        float execute(float const &value);
        double execute(double const &value);
        template <typename T> T execute(std::optional<T> const &value);

      Examples (where 123 is the minimum or maximum value (depending on configuration
      parameters set when creating the estimator):
        execute(1.0) -> 1.0
        execute(NaN) -> 123.4
        execute(2.0) -> 2.0

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T?
        output_type: T

    configuration_params:
      - type: bool
        name: useMin
        description: |-
          Impute using the minimum value encountered during training; if 'false', the maximum
          value will be used for imputation.

  # ----------------------------------------------------------------------
  - name: MinMaxScalerFeaturizer
    estimator_name: MinMaxScalerEstimator
    release_version: 0.3.6
    num_output_columns: 1
    description: |-
      Scales input based on the scale that results from the minimum and maximum values encountered
      during training.

      C++-style pseudo signature:
          template <typeanem T> double(T const &value);

      Examples:
        Given the training data [1, 2, 3, 4, 5];
          min: 1
          max: 5
          scale (<max> - <min>): 4

        execute(2) = 2 / 4
        execute(20) = 20 / 4

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double

    type_mappings:
      - input_type: T
        output_type: double

  # ----------------------------------------------------------------------
  - name: MissingDummiesFeaturizer
    estimator_name: MissingDummiesEstimator
    release_version: 0.3.6
    num_output_columns: 1
    creates_annotations: false
    description: |-
      Returns 1 if the input is null, 0 if it is not.

      C++-style pseudo signature:
          int8 execute(float const &value);
          int8 execute(double const &value);
          template <typename T> int8 execute(T const &value);

      Examples:
        1.0 -> 0
        NaN -> 1
        "foo" -> 0
        std::optional<string>() -> 1
        std::optional<string>("bar") -> 0

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T?
        output_type: int8

  # ----------------------------------------------------------------------
  - name: ModeImputerFeaturizer
    estimator_name: ModeImputerEstimator
    release_version: 0.3.6
    num_output_columns: 1
    description: |-
      Imputes (populates) values with the mode (most frequent) value encountered during
      training. The first value encountered with be used in the event that mutliple values
      we found the most number of times.

      C++-style pseudo signature:
        float execute(float const &value);
        double execute(double const &value);
        template <typename T> T execute(std::optional<T> const &value);

      Examples (where 123.4 is the mode value):
        execute(1.0) -> 1.0
        execute(NaN) -> 123.4
        execute(2.0) -> 2.0

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T?
        output_type: T

  # ----------------------------------------------------------------------
  - name: NumericalizeFeaturizer
    estimator_name: NumericalizeEstimator
    release_version: 0.3.6
    num_output_columns: 1
    description: |-
      This is the LabelEncoder, but returns a null value for categories not encountered during training.

      C++-style pseudo signature:
        template <typename T> double execute(T const &value);

      Examples:
        Assuming the training data of ["Oh", "Huh", "Heh"]...
        execute("Oh") -> double(1)
        execute("Huh") -> double(2)
        execute("Heh") -> double(3)
        # This value was not seeing at training time
        execute("Oops") -> std::numeric_limits<double>::quiet_NaN()

    templates:
      - name: T
        types:
          - int8
          - uint8
          - int16
          - uint16
          - int32
          - uint32
          - int64
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T
        output_type: double

  # ----------------------------------------------------------------------
  - name: OneHotEncoderFeaturizer
    estimator_name: OneHotEncoderEstimator
    release_version: 0.3.6
    num_output_columns: 1
    description: |-
      Produces a one hot vector based on categories calculated during training.

      C++-style pseudo signature:
        template <typename T> OneHotVector execute(T const &value);

      Examples:
        Assuming the training data [10, 20, 30, 40]...

        execute(10) -> [0, 1, 0, 0, 0]
        execute(20) -> [0, 0, 1, 0, 0]
        execute(30) -> [0, 0, 0, 1, 0]
        execute(40) -> [0, 0, 0, 0, 1]
        execute(200) -> [1, 0, 0, 0, 0]
        execute(-1) -> [1, 0, 0, 0, 0]

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T
        output_type: single_value_sparse_vector<uint8>

    configuration_params:
      - type: bool
        name: suppressUnrecognizedErrors

  # ----------------------------------------------------------------------
  - name: PCAFeaturizer
    estimator_name: PCAEstimator
    release_version: 0.3.6
    num_output_columns: 1
    description: |-
      Principal component analysis and matrix projection

      C++-style pseudo signature:
        template <typename MatrixT> MatrixT execute(MatrixT const &value);

      Examples:
        Assuming the training matrix A
        By applying PCA we get the eigenvector P
        the projecting matrix of an input matrix X is X*P^T

    templates:
      - name: T
        types:
          - float
          - double

    type_mappings:
      - input_type: matrix<T>
        output_type: matrix<T>

  # ----------------------------------------------------------------------
  - name: RobustScalerFeaturizer
    estimator_name: RobustScalerEstimator
    release_version: 0.3.6
    num_output_columns: 1
    is_output_a_template: true
    description: |-
      Remove the median and scales the data according to the quantile range.

      C++-style pseudo signature:
          float execute(TInputFloat const &value);
          double execute(TInputDouble const &value);

      Examples:
        Assuming the Training data [[ 1, -2, 2], [-2, 1, 3], [ 4, 1,-2]]

        There are 3 columns...

            column 1          column 2          column 3
               1                 -2                2
              -2                  1                3
               4                  1               -2

        For each column, we calculate the median value...

            column 1          column 2          column 3
               1                  1                2

        Also calculate the range for each column

            column 1          column 2          column 3
          4 - (-2) = 6      1 - (-2) = 3      3 - (-2) = 5

        Apply quantile range(QR) to the ranges, assuming the QR is [q_min = 25, q_max = 75], we get the scaling value = range * (q_max% - q_min%) for each column

            column 1          column 2          column 3
          6 * 50% = 3       3 * 50% = 1.5     5 * 50% = 2.5

        Remove the median and scales the original data per column

            column 1          column 2          column 3
          ( 1 - 1) / 3     (-2 - 1) / 1.5    ( 2 - 2) / 2.5
          (-2 - 1) / 3     ( 1 - 1) / 1.5    ( 3 - 2) / 2.5
          ( 4 - 1) / 3     ( 1 - 1) / 1.5    (-2 - 2) / 2.5

        The final result is

            column 1          column 2          column 3
               0                 -2                0
              -1                  0              0.4
               1                  0             -1.6

    templates:
      - name: TInputFloat
        types:
          - int8
          - int16
          - uint8
          - uint16
          - float

      - name: TInputDouble
        types:
          - int32
          - int64
          - uint32
          - uint64
          - double

    type_mappings:
      - input_type: TInputFloat
        output_type: float

      - input_type: TInputDouble
        output_type: double

    configuration_params:
      - type: bool
        name: withCentering

      - type: float?
        name: qRangeMin

      - type: float?
        name: qRangeMax

  # ----------------------------------------------------------------------
  - name: ShortGrainDropperFeaturizer
    estimator_name: ShortGrainDropperEstimator
    release_version: 0.4.0
    num_output_columns: 1
    description: |-
      Returns true to indicate that a row should be dropped if it wasn't encountered during training.

      C++-style pseudo signature:
        bool execute(std::vector<std::string> const &value);

      Examples:
        Consider the training data:

        [ ["one"], ["two"], ["two"], ["three"], ["three"], ["three"] ]

        and a ShortGrainDropper configured with minPoints set to 2. Grains ["two"] and ["three"] appear
        enough times in the training data to remain, while any other grain should be dropped:

        [ "one" ] -> true                         # drop
        [ "two" ] -> false                        # dont' drop
        [ "three" ] -> false                      # don't drop
        [ "never seen during training" ] -> true  # drop

    featurizer_is_a_template: true

    type_mappings:
      - input_type: unique_id
        output_type: bool

    configuration_params:
      - type: uint32
        name: minPoints

  # ----------------------------------------------------------------------
  - name: SimpleRollingWindowFeaturizer
    estimator_name: GrainedSimpleRollingWindowEstimator
    release_version: 0.4.0
    num_output_columns: 1
    transformer_maintains_state: true
    creates_annotations: false
    description: |-
      Calculates data based on a rolling window. Currently supports minimum and maximum. Works for any data set that is already sorted.

      Input type for this featurizer is a tuple of the grain columns and target column to find the value. It is assumed that the data is sorted in the correct order.

      C++-style pseudo signature:
        template <typename T> matrix<T> execute(std::tuple<std::vector<std::string> const &, T const &> value);

      Examples:
          A simple example would be horizon = 1, maxWindowSize = 2, and we want to take the minimum.

          +-----------+-------+-------------------+
          | grain     | target| target_minimum    |
          +===========+=======+===================+
          | A         | 10    | [[NAN]]           |
          +-----------+-------+-------------------+
          | A         | 4     | [[10]]            |
          +-----------+-------+-------------------+
          | A         | 6     | [[4]]             |
          +-----------+-------+-------------------+
          | A         | 11    | [[4]]             |
          +-----------+-------+-------------------+

          A more complex example would be, assuming we have horizon = 2, maxWindowSize = 2, minWindowSize = 2, and we want the maximum value
          +-----------+-------+-------------------+
          | grain     | target| target_max        |
          +===========+=======+===================+
          | A         | 10    | [[NAN, NAN]]      |
          +-----------+-------+-------------------+
          | A         | 4     | [[NAN, NAN]]      |
          +-----------+-------+-------------------+
          | A         | 6     | [[NAN, 10]]       |
          +-----------+-------+-------------------+
          | A         | 11    | [[10, 6]]         |
          +-----------+-------+-------------------+

    templates:
      - name: T
        types:
          # Note that optional values during output increase quite a bit of overhead when marshalling, therefore
          # this featurizer only supports those types that don't have to pay that penality. We may still want to support
          # these types in the future in some frameworks.
          #
          # - int8
          # - int16
          # - int32
          # - int64
          # - uint8
          # - uint16
          # - uint32
          # - uint64
          # - string
          - float
          - double

    type_mappings:
      - input_type: tuple<unique_id, T>
        output_type: matrix<T?>
        description: A matrix always of 1 row and column of size horizon, but the individual elements could be NaN.

    custom_enums:
      - name: SimpleRollingWindowCalculation
        description: What calculation to use on the rolling window.
        values: [Min, Max]
        underlying_type: uint8

    configuration_params:
      - type: SimpleRollingWindowCalculation
        name: windowCalculation
        description: What calculation is going to be performed over the window data.

      - type: uint32
        name: horizon
        description: The horizon value. The size of the output vector will be equal to this value.

      - type: uint32
        name: maxWindowSize
        description: The maximum number of items in a window.

      - type: uint32
        name: minWindowSize
        default_value: 1
        description: The minimum number of elements that must be in an window to perform the calculation. If there is less, NaN will be returned. Defaults to 1.

  # ----------------------------------------------------------------------
  - name: StandardScaleWrapperFeaturizer
    estimator_name: StandardScaleWrapperEstimator
    release_version: 0.3.6
    num_output_columns: 1
    description: |-
      Standardize features by removing the mean and scaling to unit variance based on input flag with_mean and with_std
      standard score of a sample x is calculated as
        z = (x - u) / s
      where u is the mean of the training samples or 0 if with_mean is false, and s is the standard deviation of the training samples or 1 if with_std is false

      C++-style pseudo signature:
        template <typeanem T> double(T const &value);

      Examples:
        Given the training data [0, 0, 1, 1];
          mean: 0.5
          std: 0.5

        execute(2) = (2 - 0.5) / 0.5 = 3 if with_mean is true and with_std is true
        execute(2) = (2 - 0.5) / 1 = 1.5 if with_mean is true and with_std is false
        execute(2) = (2 - 0) / 0.5 = 4 if with_mean is false and with_std is true
        execute(2) = (2 - 0) / 1 = 2 if with_mean is false and with_std is false

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double

    type_mappings:
      - input_type: T
        output_type: double

    configuration_params:
      - type: bool
        name: withMean

      - type: bool
        name: withStd

  # ----------------------------------------------------------------------
  - name: StringFeaturizer
    estimator_name: StringEstimator
    release_version: 0.3.6
    num_output_columns: 1
    creates_annotations: false
    description: |-
      Converts the input into a string representation based on the input's type.

      C++-style pseudo signature:
        template <typename T> string execute(T const &value);

      Examples:
        execute(1) -> "1"
        execute(3.14) -> "3.14"

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T
        output_type: string

    configuration_params:
      - type: bool
        name: useEmptyStringsForNullValues

  # ----------------------------------------------------------------------
  - name: TfidfVectorizerFeaturizer
    estimator_name: TfidfVectorizerEstimator
    release_version: 0.3.6
    num_output_columns: 1
    description: |-
      Convert a collection of raw documents to a matrix of TF-IDF features

      C++-style pseudo signature:
        TfidfVector execute(std::string const &value);

      Examples:
        Assuming the training data is...
        ["this is the first document", "this document is the second document", "and this is the third one", "is this the first document"]

        Assuming the input data is...
        "this is the first document"
        The default result will be...
        [0. , 0.469791f, 0.580286f, 0.384085f, 0. , 0. , 0.384085f, 0. , 0.384085f]

        Assuming the input data is...
        "this document is the second document"
        The default result will be...
        [0. , 0.687624f, 0. , 0.281089f, 0. , 0.538648f, 0.281089f, 0. , 0.281089f]

        Assuming the input data is...
        "and this is the third one"
        The default result will be...
        [0.511849f, 0. , 0. , 0.267104f, 0.511849f, 0. , 0.267104f, 0.511849f, 0.267104f]

        Assuming the input data is...
        "is this the first document"
        The default result will be...
        [0. , 0.469791f, ,0.580286f, 0.384085f, 0. , 0. , 0.384085f, 0. , 0.384085f]

    featurizer_is_a_template: true

    custom_enums:
      - name: AnalyzerMethod
        description: Used by Text-based parsers to determine the granularity of tokens extracted transformation.
        values: [Word, Char, Charwb]
        underlying_type: uint8

      - name: NormMethod
        values: [L1, L2, None]
        underlying_type: uint8

      - name: TfidfPolicy
        values: [Binary, UseIdf, SmoothIdf, SublinearTf]
        integer_values: [1, 2, 4, 8]
        underlying_type: uint32

    type_mappings:
      - input_type: string
        output_type: sparse_vector<float>

    configuration_params:
      - type: bool
        name: lowercase

      - type: AnalyzerMethod
        name: analyzer

      - type: string
        name: regexToken

      - type: NormMethod
        name: norm

      - type: TfidfPolicy
        name: policy

      - type: float
        name: minDf

      - type: float
        name: maxDf

      - type: uint32?
        name: topKTerms

      - type: uint32
        name: ngramRangeMin

      - type: uint32
        name: ngramRangeMax

  # ----------------------------------------------------------------------
  - name: TimeSeriesImputerFeaturizer
    estimator_name: TimeSeriesImputerEstimator
    release_version: 0.3.6
    has_dynamic_output: true
    transformer_maintains_state: true
    num_output_columns: 1
    description: |-
      Imputes rows and column values such that the generated output does not contain any
      time gaps per grain (based on the time gaps encountered during training) and that
      all missing column values are populated according to a strategy (forward fill,
      backward fill, mode, etc.).

      This Featurizer is unique in that it will produce 0:N rows, depending upon the
      input data.

      C++-style pseudo signature:
        template <typename... GrainColValueTs, typename... DataColValueTs>
        std::vector<
          std::tuple<
            bool, // true if the row was added
            std::chrono::system_clock::time_point,
            std::tuple<GrainColValueTs...>,
            std::tuple<DataColValueTs...>
          >
        > execute(
          std::chrono::system_clock::time_point const &value,
          std::tuple<GrainColValueTs...> const &grain,
          std::tuple<DataColValueTs...> const &colData
        );

      Examples:
        During training, the time period was found to be 1 day...

        Input:
          +------+-------+------------------+-------------------+
          | time | grain | forward fill col | backward fill col |
          +======+=======+==================+===================+
          | 1    | A     | 10               | None              |
          +------+-------+------------------+-------------------+
          | 2    | A     | None             | 200               |
          +------+-------+------------------+-------------------+
          | 1    | B     | -10              | -100              |
          +------+-------+------------------+-------------------+
          | 4    | A     | 40               | 400               |
          +------+-------+------------------+-------------------+
          | 6    | A     | 60               | 600               |
          +------+-------+------------------+-------------------+
          | 3    | B     | -30              | -300              |
          +------+-------+------------------+-------------------+

        Output:
          +-------+------+-------+------------------+-------------------+
          | Added | time | grain | forward fill col | backward fill col |
          +=======+======+=======+==================+===================+
          | false | 1    | A     | 10               | 200 (from 2)      |
          +-------+------+-------+------------------+-------------------+
          | false | 2    | A     | 10 (from 1)      | 200               |
          +-------+------+-------+------------------+-------------------+
          | true  | 3    | A     | 10 (from 2)      | 400 (from 4)      |
          +-------+------+-------+------------------+-------------------+
          | false | 4    | A     | 40               | 400               |
          +-------+------+-------+------------------+-------------------+
          | true  | 5    | A     | 40 (from 4)      | 600 (from 6)      |
          +-------+------+-------+------------------+-------------------+
          | false | 6    | A     | 60               | 600               |
          +-------+------+-------+------------------+-------------------+
          | false | 1    | B     | -10              | -100              |
          +-------+------+-------+------------------+-------------------+
          | true  | 2    | B     | -10 (from 1)     | -300 (from 3)     |
          +-------+------+-------+------------------+-------------------+
          | false | 3    | B     | -30              | -300              |
          +-------+------+-------+------------------+-------------------+

    # The TimeSeriesImputerFeaturizer operates on tabular data, which is different from the
    # other featurizers that typically operate on a single input. Because of these differences,
    # wrappers are generated by hand. In the future, we should strive to update the code
    # generators so that they can handle tabular data input (this will likely come when
    # we introduce the tabular data type itself).
    status: External

  # ----------------------------------------------------------------------
  - name: TruncatedSVDFeaturizer
    estimator_name: TruncatedSVDEstimator
    release_version: 0.3.6
    num_output_columns: 1
    description: |-
      Dimensionality reduction using truncated SVD algorithm

      C++-style pseudo signature:
        template <typename MatrixT> MatrixT execute(MatrixT const &value);

      Examples:
        Assuming the training matrix A
        By applying TruncatedSVD we get the right singular vector P
        the projecting matrix of an input matrix X is X*P

    templates:
      - name: T
        types:
          - float
          - double

    type_mappings:
      - input_type: matrix<T>
        output_type: matrix<T>
