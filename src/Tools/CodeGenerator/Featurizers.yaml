featurizers:
  # ----------------------------------------------------------------------
  - name: CatImputerFeaturizer
    estimator_name: CatImputerEstimator
    num_output_columns: 1
    description: |-
      *****
      *****

      This featurizer has been DEPRECATED in favor of the ModeImputerFeaturizer.

      *****
      *****

      Imputes (populates) values with the mode (most common value) encountered during
      training. This featurizer supports float and double for most (if not all) frameworks
      due to the existance of NaN in those types. Other types require 'optional' support
      within the host frameworks and programming languages.

      C++-style pseudo signature:
        float execute(float const &value);
        double execute(double const &value);
        template <typename T> T execute(std::optional<T> const &value);

      Examples (where 55.5 is the mode value):
        execute(1.0) -> 1.0
        execute(NaN) -> 55.5
        execute(2.0) -> 2.0

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T
        is_input_optional: true
        output_type: T

  # ----------------------------------------------------------------------
  - name: CountVectorizerFeaturizer
    estimator_name: CountVectorizerEstimator
    num_output_columns: 1
    description: |-
      Returns the count of the number of occurrances of each distinct item according to a
      vocabulary established during training.

      C++-style pseudo signature:
        CountVector execute(std::string const &value);

      Examples:
        Assuming the training data is...
        ["orange apple orange grape", "grape carrot carrot apple", "peach banana orange banana"]

        The input data is...
        "banana grape grape apple apple apple orange"

        The result will be computed by...
          categorize and compute each word's number of apperance in input data, we have "apple -> 3", "banana -> 1", "grape -> 2", "orange -> 1"
          construct a dictionary and assign id for each unique word using training data, we have "apple -> 0", "banana -> 1", "grape -> 3", "orange -> 4"
          generate TFStruct by combining <word's id, word's number of apperance>

        The result is...
        [3, 1, 0, 2, 1]

    featurizer_is_a_template: true

    type_mappings:
      - input_type: string
        output_type: sparse_vector<uint32>

    custom_enums:
      - name: AnalyzerMethod
        description: Used by Text-based parsers to determine the granularity of tokens extracted transformation.
        values: [Word, Char, Charwb]
        underlying_type: uint8

    configuration_params:
      - type: bool
        name: lower
        is_optional: false

      - type: AnalyzerMethod
        name: analyzer
        is_optional: false

      - type: string
        name: regexToken
        is_optional: false

      - type: float
        name: maxDf
        is_optional: false

      - type: float
        name: minDf
        is_optional: false

      - type: uint32
        name: topKTerms
        is_optional: true

      - type: uint32
        name: ngramRangeMin
        is_optional: false

      - type: uint32
        name: ngramRangeMax
        is_optional: false

      - type: bool
        name: binary
        is_optional: false

  # ----------------------------------------------------------------------
  - name: DateTimeFeaturizer
    estimator_name: DateTimeEstimator
    num_output_columns: 21
    creates_annotations: false
    description: |-
      Extracts various datetime-related values from a UTC time_point.

      C++-style pseudo signature:
        TimePoint execute(std::chrono::system_clock::time_point const &value);

      Examples:
        Given a time_point 'value' representing "November 17, 1976 12:27:04PM":

        "November 17, 1976 12:27:04PM" => {
          "year": 1976,
          "month": 11,
          "day": 17,
          "hour": 12,
          "minute": 27,
          "second": 04,
          "amPm": 2,        // PM
          "hour12": 12,
          "dayOfWeek": 3,   // Wednesday
          "dayOfQuarter": 48,
          "dayOfYear": 321,
          "weekOfMonth": 2,
          "quarterOfYear": 4,
          "halfOfYear": 2,
          "weekIso": 47,
          "yearIso": 1976,
          "monthLabel": "November",
          "amPmLabel": "pm",
          "dayOfWeekLabel": "Wednesday",
          "holidayName": "",
          "isPaidTimeOff": 0
        }

    type_mappings:
      - input_type: datetime
        output_type: TimePoint

    configuration_params:
      - type: string
        name: optionalCountryName
        is_optional: true

      - type: string
        name: optionalDataRootDir
        is_optional: true

    custom_structs:
      - name: TimePoint
        members:
          - type: int32
            name: year
          - type: uint8
            name: month
          - type: uint8
            name: day
          - type: uint8
            name: hour
          - type: uint8
            name: minute
          - type: uint8
            name: second
          - type: uint8
            name: amPm
          - type: uint8
            name: hour12
          - type: uint8
            name: dayOfWeek
          - type: uint8
            name: dayOfQuarter
          - type: uint16
            name: dayOfYear
          - type: uint16
            name: weekOfMonth
          - type: uint8
            name: quarterOfYear
          - type: uint8
            name: halfOfYear
          - type: uint8
            name: weekIso
          - type: int32
            name: yearIso
          - type: string
            name: monthLabel
          - type: string
            name: amPmLabel
          - type: string
            name: dayOfWeekLabel
          - type: string
            name: holidayName
          - type: uint8
            name: isPaidTimeOff

  # ----------------------------------------------------------------------
  - name: FromStringFeaturizer
    estimator_name: FromStringEstimator
    num_output_columns: 1
    creates_annotations: false
    description: |-
      Converts from a string to a scalar type.

      C++-style pseudo signature:
        int32 execute(std::string const &value);
        bool execute(std::string const &value);

      Examples:
        execute("True") -> true [bool]
        execute("10") -> 10 [int32]

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    is_input_a_template: false
    is_output_a_template: true

    type_mappings:
      - input_type: string
        output_type: T

  # ----------------------------------------------------------------------
  - name: HashOneHotVectorizerFeaturizer
    estimator_name: HashOneHotVectorizerEstimator
    num_output_columns: 1
    creates_annotations: false
    description: |-
      Hashes the input to a categorical value, then produces a one hot encoded vector
      based on that value.

      C++-style pseudo signature:
          template <typename T> HashOneHotVectorizerStruct execute(T const &value);

      Examples:
        Assuming the hashing algorithm...
          "A" -> 1
          "B" -> 2
          "C" -> 5

        and 'numCols' set to 8:

          execute("A") -> [1, 0, 0, 0, 0, 0, 0, 0]
          execute("B") -> [0, 1, 0, 0, 0, 0, 0, 0]
          execute("C") -> [0, 0, 0, 0, 1, 0, 0, 0]

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T
        output_type: single_value_sparse_vector<uint8>

    configuration_params:
      - type: uint32
        name: hashingSeedVal
        is_optional: false

      - type: uint32
        name: numCols
        is_optional: false

  # ----------------------------------------------------------------------
  - name: ImputationMarkerFeaturizer
    estimator_name: ImputationMarkerEstimator
    num_output_columns: 1
    creates_annotations: false
    description: |-
      Returns true if the input is null, false if it is not.

      C++-style pseudo signature:
        bool execute(float const &value);
        bool execute(double const &value);
        template <typename T> bool execute(std::optional<T> const &value);

      Examples:
        3.0 -> false
        NaN -> true
        "foo" -> false
        std::optional<string>() -> true
        std::optional<string>("bar") -> false

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T
        is_input_optional: true
        output_type: bool

  # ----------------------------------------------------------------------
  - name: L1NormalizeFeaturizer
    estimator_name: L1NormalizeEstimator
    num_output_columns: 1
    description: |-
      Computes the L1 norm for a provided data set and normalize every row so that
      its L1 norm is 1

      C++-style pseudo signature:
        template <typename IteratorT> std::vector<std::double_t> execute(std::pair<IteratorT, IteratorT> const &value);
        template <typename IteratorT> std::vector<std::double_t> execute(std::tuple<IteratorT, IteratorT> const &value);

      Examples:
        Given the training data
        [[4, 1, 2, 2],
         [1, 3, 9, 3],
         [5, 7, 5, 1]]

         L1 norms for each row are: [9, 16, 18]

        execute([4,1,2,2]) = [4/9, 1/9, 2/9, 2/9]
        execute([1,3,9,3]) = [1/16, 3/16, 9/16, 3/16]

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double

    type_mappings:
      - input_type: vector<T>
        output_type: vector<double>

  # ----------------------------------------------------------------------
  - name: L2NormalizeFeaturizer
    estimator_name: L2NormalizeEstimator
    num_output_columns: 1
    description: |-
      Computes the L2 norm for a provided data set and normalize every row so that
      its L2 norm is 1

      C++-style pseudo signature:
        template <typename IteratorT> std::vector<std::double_t> execute(std::pair<IteratorT, IteratorT> const &value);
        template <typename IteratorT> std::vector<std::double_t> execute(std::tuple<IteratorT, IteratorT> const &value);

      Examples:
        Given the training data
        [[4, 1, 2, 2],
         [1, 3, 9, 3],
         [5, 7, 5, 1]]

         L2 norms for each row are: [5, 10, 10]

        execute([4,1,2,2]) = [4/5, 1/5, 2/5, 2/5]
        execute([1,3,9,3]) = [1/10, 3/10, 9/10, 3/10]

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double

    type_mappings:
      - input_type: vector<T>
        output_type: vector<double>

  # ----------------------------------------------------------------------
  - name: LabelEncoderFeaturizer
    estimator_name: LabelEncoderEstimator
    num_output_columns: 1
    description: |-
      Returns a unique id for the input based on all values encountered during training.

      C++-style pseudo signature:
        template <typename T> uint32 execute(T const &value);

      Examples:
        Assuming the training data of ["A", "B", "C"]...

        execute("A") -> 1
        execute("B") -> 2
        execute("C") -> 3
        execute("This value was not seen during training") -> 0

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T
        output_type: uint32

    configuration_params:
      - type: bool
        name: suppressUnrecognizedErrors
        is_optional: false

  # ----------------------------------------------------------------------
  - name: MaxAbsScalerFeaturizer
    estimator_name: MaxAbsScalerEstimator
    num_output_columns: 1
    is_output_a_template: true
    description: |-
      Scales input based on the maximum absolute value of all data encountered during training.

      C++-style pseudo signature:
        float execute(uint16 value);
        double execute(uint32 value);

      Examples:
        Given a training set of [1.0, -2.0, 3.0, -4.0], where 4.0 is the absolute value of the
        maximum value encountered...

        execute(1.0) -> 1.0 / 4.0
        execute(-4.0) -> -4.0 / 4.0
        execute(100.0) -> 100 / 4.0

    templates:
      - name: TInputFloat
        types:
          - int8
          - int16
          - uint8
          - uint16
          - float

      - name: TInputDouble
        types:
          - int32
          - int64
          - uint32
          - uint64
          - double

    type_mappings:
      - input_type: TInputFloat
        output_type: float

      - input_type: TInputDouble
        output_type: double

  # ----------------------------------------------------------------------
  - name: MaxNormalizeFeaturizer
    estimator_name: MaxNormalizeEstimator
    num_output_columns: 1
    description: |-
      Computes the max norm for a provided data set and normalize every row so that
      its max norm is 1

      C++-style pseudo signature:
        template <typename IteratorT> std::vector<std::double_t> execute(std::pair<IteratorT, IteratorT> const &value);
        template <typename IteratorT> std::vector<std::double_t> execute(std::tuple<IteratorT, IteratorT> const &value);

      Examples:
        Given the training data
        [[4, 1, 2, 2],
         [1, 3, 9, 3],
         [5, 7, 5, 1]]

         Max norms for each row are: [4, 9, 7]

        execute([4,1,2,2]) = [4/4, 1/4, 2/4, 2/4]
        execute([1,3,9,3]) = [1/9, 3/9, 9/9, 3/9]

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double

    type_mappings:
      - input_type: vector<T>
        output_type: vector<double>

  # ----------------------------------------------------------------------
  - name: MeanImputerFeaturizer
    estimator_name: MeanImputerEstimator
    num_output_columns: 1
    description: |-
      Imputes (populates) values with the mean (average) value encountered during
      training.

      C++-style pseudo signature:
        float execute(float const &value);
        double execute(double const &value);
        template <typename T> T execute(std::optional<T> const &value);

      Examples (where 123.4 is the mean value):
        execute(1.0) -> 1.0
        execute(NaN) -> 123.4
        execute(2.0) -> 2.0

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double

    type_mappings:
      - input_type: T
        is_input_optional: true
        output_type: double

  # ----------------------------------------------------------------------
  - name: MedianImputerFeaturizer
    estimator_name: MedianImputerEstimator
    num_output_columns: 1
    is_output_a_template: true
    description: |-
      Imputes (populates) values with the median value encountered during
      training.

      C++-style pseudo signature:
        float execute(float const &value);
        double execute(double const &value);
        template <typename T> T execute(std::optional<T> const &value);

      Examples (where 123.4 is the median value):
        execute(1.0) -> 1.0
        execute(NaN) -> 123.4
        execute(2.0) -> 2.0

    templates:
      - name: TIntegerOrNumeric
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double

      - name: TInputNoInterpolation
        types:
          - bool
          - string

    type_mappings:
      - input_type: TIntegerOrNumeric
        is_input_optional: true
        output_type: double

      - input_type: TInputNoInterpolation
        is_input_optional: true
        output_type: TInputNoInterpolation

  # ----------------------------------------------------------------------
  - name: MinMaxImputerFeaturizer
    estimator_name: MinMaxImputerEstimator
    num_output_columns: 1
    description: |-
      Imputes (populates) values with the minimum or maximum value encountered during
      training.

      C++-style pseudo signature:
        float execute(float const &value);
        double execute(double const &value);
        template <typename T> T execute(std::optional<T> const &value);

      Examples (where 123 is the minimum or maximum value (depending on configuration
      parameters set when creating the estimator):
        execute(1.0) -> 1.0
        execute(NaN) -> 123.4
        execute(2.0) -> 2.0

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T
        is_input_optional: true
        output_type: T

    configuration_params:
      - type: bool
        name: useMin
        description: |-
          Impute using the minimum value encountered during training; if 'false', the maximum
          value will be used for imputation.

  # ----------------------------------------------------------------------
  - name: MinMaxScalerFeaturizer
    estimator_name: MinMaxScalerEstimator
    num_output_columns: 1
    description: |-
      Scales input based on the scale that results from the minimum and maximum values encountered
      during training.

      C++-style pseudo signature:
          template <typeanem T> double(T const &value);

      Examples:
        Given the training data [1, 2, 3, 4, 5];
          min: 1
          max: 5
          scale (<max> - <min>): 4

        execute(2) = 2 / 4
        execute(20) = 20 / 4

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double

    type_mappings:
      - input_type: T
        output_type: double

  # ----------------------------------------------------------------------
  - name: MissingDummiesFeaturizer
    estimator_name: MissingDummiesEstimator
    num_output_columns: 1
    creates_annotations: false
    description: |-
      Returns 1 if the input is null, 0 if it is not.

      C++-style pseudo signature:
          int8 execute(float const &value);
          int8 execute(double const &value);
          template <typename T> int8 execute(T const &value);

      Examples:
        1.0 -> 0
        NaN -> 1
        "foo" -> 0
        std::optional<string>() -> 1
        std::optional<string>("bar") -> 0

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T
        is_input_optional: true
        output_type: int8

  # ----------------------------------------------------------------------
  - name: ModeImputerFeaturizer
    estimator_name: ModeImputerEstimator
    num_output_columns: 1
    description: |-
      Imputes (populates) values with the mode (most frequent) value encountered during
      training. The first value encountered with be used in the event that mutliple values
      we found the most number of times.

      C++-style pseudo signature:
        float execute(float const &value);
        double execute(double const &value);
        template <typename T> T execute(std::optional<T> const &value);

      Examples (where 123.4 is the mode value):
        execute(1.0) -> 1.0
        execute(NaN) -> 123.4
        execute(2.0) -> 2.0

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T
        is_input_optional: true
        output_type: T

  # ----------------------------------------------------------------------
  - name: NumericalizeFeaturizer
    estimator_name: NumericalizeEstimator
    num_output_columns: 1
    description: |-
      This is the LabelEncoder, but returns a null value for categories not encountered during training.

      C++-style pseudo signature:
        template <typename T> double execute(T const &value);

      Examples:
        Assuming the training data of ["Oh", "Huh", "Heh"]...
        execute("Oh") -> double(1)
        execute("Huh") -> double(2)
        execute("Heh") -> double(3)
        # This value was not seeing at training time
        execute("Oops") -> std::numeric_limits<double>::quiet_NaN()

    templates:
      - name: T
        types:
          - int8
          - uint8
          - int16
          - uint16
          - int32
          - uint32
          - int64
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T
        output_type: double

  # ----------------------------------------------------------------------
  - name: OneHotEncoderFeaturizer
    estimator_name: OneHotEncoderEstimator
    num_output_columns: 1
    description: |-
      Produces a one hot vector based on categories calculated during training.

      C++-style pseudo signature:
        template <typename T> OneHotVector execute(T const &value);

      Examples:
        Assuming the training data [10, 20, 30, 40]...

        execute(10) -> [0, 1, 0, 0, 0]
        execute(20) -> [0, 0, 1, 0, 0]
        execute(30) -> [0, 0, 0, 1, 0]
        execute(40) -> [0, 0, 0, 0, 1]
        execute(200) -> [1, 0, 0, 0, 0]
        execute(-1) -> [1, 0, 0, 0, 0]

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T
        output_type: single_value_sparse_vector<uint8>

    configuration_params:
      - type: bool
        name: suppressUnrecognizedErrors
        is_optional: false

  # ----------------------------------------------------------------------
  - name: PCAFeaturizer
    estimator_name: PCAEstimator
    num_output_columns: 1
    description: |-
      Principal component analysis and matrix projection

      C++-style pseudo signature:
        template <typename MatrixT> MatrixT execute(MatrixT const &value);

      Examples:
        Assuming the training matrix A
        By applying PCA we get the eigenvector P
        the projecting matrix of an input matrix X is X*P^T

    templates:
      - name: T
        types:
          - float
          - double

    type_mappings:
      - input_type: matrix<T>
        output_type: matrix<T>

  # ----------------------------------------------------------------------
  - name: RobustScalerFeaturizer
    estimator_name: RobustScalerEstimator
    num_output_columns: 1
    is_output_a_template: true
    description: |-
      MinMaxScalerEstimator + centering?

      C++-style pseudo signature:
          TODO

      Examples:
        TODO

    templates:
      - name: TInputFloat
        types:
          - int8
          - int16
          - uint8
          - uint16
          - float

      - name: TInputDouble
        types:
          - int32
          - int64
          - uint32
          - uint64
          - double

    type_mappings:
      - input_type: TInputFloat
        output_type: float

      - input_type: TInputDouble
        output_type: double

    configuration_params:
      - type: bool
        name: withCentering
        is_optional: false

      - type: float
        name: qRangeMin
        is_optional: true

      - type: float
        name: qRangeMax
        is_optional: true

  # ----------------------------------------------------------------------
  - name: StandardScaleWrapperFeaturizer
    estimator_name: StandardScaleWrapperEstimator
    num_output_columns: 1
    description: |-
      Standardize features by removing the mean and scaling to unit variance based on input flag with_mean and with_std
      standard score of a sample x is calculated as
        z = (x - u) / s
      where u is the mean of the training samples or 0 if with_mean is false, and s is the standard deviation of the training samples or 1 if with_std is false

      C++-style pseudo signature:
        template <typeanem T> double(T const &value);

      Examples:
        Given the training data [0, 0, 1, 1];
          mean: 0.5
          std: 0.5

        execute(2) = (2 - 0.5) / 0.5 = 3 if with_mean is true and with_std is true
        execute(2) = (2 - 0.5) / 1 = 1.5 if with_mean is true and with_std is false
        execute(2) = (2 - 0) / 0.5 = 4 if with_mean is false and with_std is true
        execute(2) = (2 - 0) / 1 = 2 if with_mean is false and with_std is false

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double

    type_mappings:
      - input_type: T
        output_type: double

    configuration_params:
      - type: bool
        name: withMean
        is_optional: false

      - type: bool
        name: withStd
        is_optional: false

  # ----------------------------------------------------------------------
  - name: StringFeaturizer
    estimator_name: StringEstimator
    num_output_columns: 1
    creates_annotations: false
    description: |-
      Converts the input into a string representation based on the input's type.

      C++-style pseudo signature:
        template <typename T> string execute(T const &value);

      Examples:
        execute(1) -> "1"
        execute(3.14) -> "3.14"

    templates:
      - name: T
        types:
          - int8
          - int16
          - int32
          - int64
          - uint8
          - uint16
          - uint32
          - uint64
          - float
          - double
          - bool
          - string

    type_mappings:
      - input_type: T
        output_type: string

    configuration_params:
      - type: bool
        name: useEmptyStringsForNullValues
        is_optional: false

  # ----------------------------------------------------------------------
  - name: TfidfVectorizerFeaturizer
    estimator_name: TfidfVectorizerEstimator
    num_output_columns: 1
    description: |-
      Convert a collection of raw documents to a matrix of TF-IDF features

      C++-style pseudo signature:
        TfidfVector execute(std::string const &value);

      Examples:
        Assuming the training data is...
        ["this is the first document", "this document is the second document", "and this is the third one", "is this the first document"]

        Assuming the input data is...
        "this is the first document"
        The default result will be...
        [0. , 0.469791f, 0.580286f, 0.384085f, 0. , 0. , 0.384085f, 0. , 0.384085f]

        Assuming the input data is...
        "this document is the second document"
        The default result will be...
        [0. , 0.687624f, 0. , 0.281089f, 0. , 0.538648f, 0.281089f, 0. , 0.281089f]

        Assuming the input data is...
        "and this is the third one"
        The default result will be...
        [0.511849f, 0. , 0. , 0.267104f, 0.511849f, 0. , 0.267104f, 0.511849f, 0.267104f]

        Assuming the input data is...
        "is this the first document"
        The default result will be...
        [0. , 0.469791f, ,0.580286f, 0.384085f, 0. , 0. , 0.384085f, 0. , 0.384085f]

    featurizer_is_a_template: true

    custom_enums:
      - name: AnalyzerMethod
        description: Used by Text-based parsers to determine the granularity of tokens extracted transformation.
        values: [Word, Char, Charwb]
        underlying_type: uint8

      - name: NormMethod
        values: [L1, L2]
        underlying_type: uint8

      - name: TfidfPolicy
        values: [Binary, UseIdf, SmoothIdf, SublinearTf]
        integer_values: [1, 2, 4, 8]
        underlying_type: uint32

    type_mappings:
      - input_type: string
        output_type: sparse_vector<float>

    configuration_params:
      - type: bool
        name: lowercase
        is_optional: false

      - type: AnalyzerMethod
        name: analyzer
        is_optional: false

      - type: string
        name: regexToken
        is_optional: false

      - type: NormMethod
        name: norm
        is_optional: false

      - type: TfidfPolicy
        name: policy
        is_optional: false

      - type: float
        name: minDf
        is_optional: false

      - type: float
        name: maxDf
        is_optional: false

      - type: uint32
        name: topKTerms
        is_optional: true

      - type: uint32
        name: ngramRangeMin
        is_optional: false

      - type: uint32
        name: ngramRangeMax
        is_optional: false

  # ----------------------------------------------------------------------
  - name: TimeSeriesImputerFeaturizer
    estimator_name: TimeSeriesImputerEstimator
    num_output_columns: 1
    description: |-
      Imputes rows and column values such that the generated output does not contain any
      time gaps per grain (based on the time gaps encountered during training) and that
      all missing column values are populated according to a strategy (forward fill,
      backward fill, mode, etc.).

      This Featurizer is unique in that it will produce 0:N rows, depending upon the
      input data.

      C++-style pseudo signature:
        template <typename... GrainColValueTs, typename... DataColValueTs>
        std::vector<
          std::tuple<
            bool, // true if the row was added
            std::chrono::system_clock::time_point,
            std::tuple<GrainColValueTs...>,
            std::tuple<DataColValueTs...>
          >
        > execute(
          std::chrono::system_clock::time_point const &value,
          std::tuple<GrainColValueTs...> const &grain,
          std::tuple<DataColValueTs...> const &colData
        );

      Examples:
        During training, the time period was found to be 1 day...

        Input:
          +------+-------+------------------+-------------------+
          | time | grain | forward fill col | backward fill col |
          +======+=======+==================+===================+
          | 1    | A     | 10               | None              |
          +------+-------+------------------+-------------------+
          | 2    | A     | None             | 200               |
          +------+-------+------------------+-------------------+
          | 1    | B     | -10              | -100              |
          +------+-------+------------------+-------------------+
          | 4    | A     | 40               | 400               |
          +------+-------+------------------+-------------------+
          | 6    | A     | 60               | 600               |
          +------+-------+------------------+-------------------+
          | 3    | B     | -30              | -300              |
          +------+-------+------------------+-------------------+

        Output:
          +-------+------+-------+------------------+-------------------+
          | Added | time | grain | forward fill col | backward fill col |
          +=======+======+=======+==================+===================+
          | false | 1    | A     | 10               | 200 (from 2)      |
          +-------+------+-------+------------------+-------------------+
          | false | 2    | A     | 10 (from 1)      | 200               |
          +-------+------+-------+------------------+-------------------+
          | true  | 3    | A     | 10 (from 2)      | 400 (from 4)      |
          +-------+------+-------+------------------+-------------------+
          | false | 4    | A     | 40               | 400               |
          +-------+------+-------+------------------+-------------------+
          | true  | 5    | A     | 40 (from 4)      | 600 (from 6)      |
          +-------+------+-------+------------------+-------------------+
          | false | 6    | A     | 60               | 600               |
          +-------+------+-------+------------------+-------------------+
          | false | 1    | B     | -10              | -100              |
          +-------+------+-------+------------------+-------------------+
          | true  | 2    | B     | -10 (from 1)     | -300 (from 3)     |
          +-------+------+-------+------------------+-------------------+
          | false | 3    | B     | -30              | -300              |
          +-------+------+-------+------------------+-------------------+

    # The TimeSeriesImputerFeaturizer operates on tabular data, which is different from the
    # other featurizers that typically operate on a single input. Because of these differences,
    # wrappers are generated by hand. In the future, we should strive to update the code
    # generators so that they can handle tabular data input (this will likely come when
    # we introduce the tabular data type itself).
    status: External

  # ----------------------------------------------------------------------
  - name: TruncatedSVDFeaturizer
    estimator_name: TruncatedSVDEstimator
    num_output_columns: 1
    description: |-
      Dimensionality reduction using truncated SVD algorithm

      C++-style pseudo signature:
        template <typename MatrixT> MatrixT execute(MatrixT const &value);

      Examples:
        Assuming the training matrix A
        By applying TruncatedSVD we get the right singular vector P
        the projecting matrix of an input matrix X is X*P

    templates:
      - name: T
        types:
          - float
          - double

    type_mappings:
      - input_type: matrix<T>
        output_type: matrix<T>
