# --------------------------------------------------------------------------------
# |
# |  WARNING:
# |  This file was generated; any local changes will be overwritten during
# |  future invocations of the generator!
# |
# |  Generated by: <SimpleSchemaGenerator>/Plugins/Impl/PythonSerializationImpl.py
# |  Generated on: 2020-02-11 09:12:55.709184
# |
# --------------------------------------------------------------------------------
import copy
import sys

from collections import OrderedDict

import six

import CommonEnvironment
from CommonEnvironment.TypeInfo import Arity
from CommonEnvironment.TypeInfo.AnyOfTypeInfo import AnyOfTypeInfo
from CommonEnvironment.TypeInfo.ClassTypeInfo import ClassTypeInfo
from CommonEnvironment.TypeInfo.DictTypeInfo import DictTypeInfo
from CommonEnvironment.TypeInfo.GenericTypeInfo import GenericTypeInfo
from CommonEnvironment.TypeInfo.ListTypeInfo import ListTypeInfo

from CommonEnvironment.TypeInfo.FundamentalTypes.Serialization.PythonCodeVisitor import PythonCodeVisitor
from CommonEnvironment.TypeInfo.FundamentalTypes.Serialization.StringSerialization import StringSerialization

# <Unused import> pylint: disable = W0611
# <Unused import> pylint: disable = W0614
from CommonEnvironment.TypeInfo.FundamentalTypes.All import *               # <Wildcard import> pylint: disable = W0401

# <Standard import should be placed before...> pylint: disable = C0411

# ----------------------------------------------------------------------
import rtyaml
import yaml

from CommonEnvironment.CallOnExit import CallOnExit
from CommonEnvironment import FileSystem
from CommonEnvironment.TypeInfo.FundamentalTypes.Serialization.YamlSerialization import YamlSerialization


# ----------------------------------------------------------------------
# <Method name "..." doesn't conform to PascalCase naming style> pylint: disable = C0103
# <Line too long> pylint: disable = C0301
# <Too many lines in module> pylint: disable = C0302
# <Wrong hanging indentation> pylint: disable = C0330

# <Too few public methods> pylint: disable = R0903
# <Too many public methods> pylint: disable = R0904
# <Too many branches> pylint: disable = R0912
# <Too many statements> pylint: disable = R0915


# ----------------------------------------------------------------------
class SerializationException(Exception):
    def __init__(self, ex_or_string):
        if isinstance(ex_or_string, six.string_types):
            super(SerializationException, self).__init__(ex_or_string)
        else:
            super(SerializationException, self).__init__(str(ex_or_string))

            self.__dict__ = copy.deepcopy(ex_or_string.__dict__)


class UniqueKeySerializationException(SerializationException):              pass
class SerializeException(SerializationException):                           pass
class DeserializeException(SerializationException):                         pass


class DoesNotExist(object):                                                 pass


# ----------------------------------------------------------------------
# |
# |  Utility Methods
# |
# ----------------------------------------------------------------------
def Deserialize(
    root,
    process_additional_data=False,
    always_include_optional=False,
):
    """Convenience method that deserializes all top-level elements"""

    if isinstance(root, six.string_types):
            if FileSystem.IsFilename(root):
                with open(root) as f:
                    root = rtyaml.load(f)
            else:
                root = rtyaml.load(root)

    result = _CreatePythonObject(
            attributes=None,
        )

    this_result = Deserialize_custom_structs(
        root,
        is_root=True,
        process_additional_data=process_additional_data,
        always_include_optional=always_include_optional,

    )
    if this_result is not DoesNotExist:
        setattr(result, "custom_structs", this_result)
    elif always_include_optional:
        setattr(result, "custom_structs", [])

    this_result = Deserialize_custom_enums(
        root,
        is_root=True,
        process_additional_data=process_additional_data,
        always_include_optional=always_include_optional,

    )
    if this_result is not DoesNotExist:
        setattr(result, "custom_enums", this_result)
    elif always_include_optional:
        setattr(result, "custom_enums", [])

    this_result = Deserialize_featurizers(
        root,
        is_root=True,
        process_additional_data=process_additional_data,
        always_include_optional=always_include_optional,

    )
    if this_result is not DoesNotExist:
        setattr(result, "featurizers", this_result)
    elif always_include_optional:
        setattr(result, "featurizers", [])

    return result


# ----------------------------------------------------------------------
def Deserialize_custom_structs(
    items,
    process_additional_data=False,
    always_include_optional=False,
    is_root=False,
):
    """Deserializes 'custom_structs' from a YAML object to a python object"""

    if isinstance(items, six.string_types):
        if FileSystem.IsFilename(items):
            with open(items) as f:
                items = rtyaml.load(f)
        else:
            items = rtyaml.load(items)

    if not isinstance(items, list):
        if isinstance(items, dict) and "custom_structs" in items:
            items = items["custom_structs"]
        elif not isinstance(items, dict) and hasattr(items, "custom_structs"):
            items = getattr(items, "custom_structs")
        elif is_root:
            items = DoesNotExist

    try:
        try:
            items = Deserializer().custom_structs(
                items,
                process_additional_data=process_additional_data,
                always_include_optional=always_include_optional,
            )

            if items is DoesNotExist:
                items = []
        except:
            _DecorateActiveException("custom_structs")
    except SerializationException:
        raise
    except Exception as ex:
        raise DeserializeException(ex)

    return items


# ----------------------------------------------------------------------
def Deserialize_custom_enums(
    items,
    process_additional_data=False,
    always_include_optional=False,
    is_root=False,
):
    """Deserializes 'custom_enums' from a YAML object to a python object"""

    if isinstance(items, six.string_types):
        if FileSystem.IsFilename(items):
            with open(items) as f:
                items = rtyaml.load(f)
        else:
            items = rtyaml.load(items)

    if not isinstance(items, list):
        if isinstance(items, dict) and "custom_enums" in items:
            items = items["custom_enums"]
        elif not isinstance(items, dict) and hasattr(items, "custom_enums"):
            items = getattr(items, "custom_enums")
        elif is_root:
            items = DoesNotExist

    try:
        try:
            items = Deserializer().custom_enums(
                items,
                process_additional_data=process_additional_data,
                always_include_optional=always_include_optional,
            )

            if items is DoesNotExist:
                items = []
        except:
            _DecorateActiveException("custom_enums")
    except SerializationException:
        raise
    except Exception as ex:
        raise DeserializeException(ex)

    return items


# ----------------------------------------------------------------------
def Deserialize_featurizers(
    items,
    process_additional_data=False,
    always_include_optional=False,
    is_root=False,
):
    """Deserializes 'featurizers' from a YAML object to a python object"""

    if isinstance(items, six.string_types):
        if FileSystem.IsFilename(items):
            with open(items) as f:
                items = rtyaml.load(f)
        else:
            items = rtyaml.load(items)

    if not isinstance(items, list):
        if isinstance(items, dict) and "featurizers" in items:
            items = items["featurizers"]
        elif not isinstance(items, dict) and hasattr(items, "featurizers"):
            items = getattr(items, "featurizers")
        elif is_root:
            items = DoesNotExist

    try:
        try:
            items = Deserializer().featurizers(
                items,
                process_additional_data=process_additional_data,
                always_include_optional=always_include_optional,
            )
        except:
            _DecorateActiveException("featurizers")
    except SerializationException:
        raise
    except Exception as ex:
        raise DeserializeException(ex)

    return items


# ----------------------------------------------------------------------
# |
# |  Type Infos
# |
# ----------------------------------------------------------------------
custom_structs_TypeInfo                                                     = ClassTypeInfo(OrderedDict([ ( "name", StringTypeInfo(min_length=1) ), ( "description", StringTypeInfo(min_length=0, arity=Arity.FromString('?')) ), ( "members", ClassTypeInfo(OrderedDict([ ( "type", StringTypeInfo(min_length=1) ), ( "name", StringTypeInfo(min_length=1) ), ( "description", StringTypeInfo(min_length=0, arity=Arity.FromString('?')) ), ( "is_optional", BoolTypeInfo(arity=Arity.FromString('?')) ) ]), require_exact_match=True, arity=Arity.FromString('+')) ) ]), require_exact_match=True, arity=Arity.FromString('*'))
custom_enums_TypeInfo                                                       = ClassTypeInfo(OrderedDict([ ( "name", StringTypeInfo(min_length=1) ), ( "description", StringTypeInfo(min_length=0, arity=Arity.FromString('?')) ), ( "starting_index", IntTypeInfo(min=0, arity=Arity.FromString('?')) ), ( "underlying_type", StringTypeInfo(min_length=1, arity=Arity.FromString('?')) ), ( "values", StringTypeInfo(min_length=1, arity=Arity.FromString('+')) ), ( "integer_values", IntTypeInfo(arity=Arity.FromString('*')) ) ]), require_exact_match=True, arity=Arity.FromString('*'))
featurizers_TypeInfo                                                        = PythonCodeVisitor.LoadTypeInfo(ClassTypeInfo(OrderedDict([ ( "name", StringTypeInfo(min_length=1) ), ( "estimator_name", StringTypeInfo(min_length=1) ), ( "release_version", StringTypeInfo(min_length=1) ), ( "updated_version", StringTypeInfo(min_length=1, arity=Arity.FromString('?')) ), ( "deprecated_version", StringTypeInfo(min_length=1, arity=Arity.FromString('?')) ), ( "num_output_columns", IntTypeInfo(min=1) ), ( "description", StringTypeInfo(min_length=0, arity=Arity.FromString('?')) ), ( "status", EnumTypeInfo([ 'Pending', 'External', 'Available', ], arity=Arity.FromString('?')) ), ( "has_dynamic_output", BoolTypeInfo(arity=Arity.FromString('?')) ), ( "transformer_maintains_state", BoolTypeInfo(arity=Arity.FromString('?')) ), ( "creates_annotations", BoolTypeInfo(arity=Arity.FromString('?')) ), ( "custom_structs", ClassTypeInfo(OrderedDict([ ( "name", StringTypeInfo(min_length=1) ), ( "description", StringTypeInfo(min_length=0, arity=Arity.FromString('?')) ), ( "members", ClassTypeInfo(OrderedDict([ ( "type", StringTypeInfo(min_length=1) ), ( "name", StringTypeInfo(min_length=1) ), ( "description", StringTypeInfo(min_length=0, arity=Arity.FromString('?')) ), ( "is_optional", BoolTypeInfo(arity=Arity.FromString('?')) ) ]), require_exact_match=True, arity=Arity.FromString('+')) ) ]), require_exact_match=True, arity=Arity.FromString('*')) ), ( "custom_enums", ClassTypeInfo(OrderedDict([ ( "name", StringTypeInfo(min_length=1) ), ( "description", StringTypeInfo(min_length=0, arity=Arity.FromString('?')) ), ( "starting_index", IntTypeInfo(min=0, arity=Arity.FromString('?')) ), ( "underlying_type", StringTypeInfo(min_length=1, arity=Arity.FromString('?')) ), ( "values", StringTypeInfo(min_length=1, arity=Arity.FromString('+')) ), ( "integer_values", IntTypeInfo(arity=Arity.FromString('*')) ) ]), require_exact_match=True, arity=Arity.FromString('*')) ), ( "configuration_params", ClassTypeInfo(OrderedDict([ ( "type", 16 ), ( "name", 17 ), ( "description", 18 ), ( "is_optional", 19 ) ]), require_exact_match=True, arity=Arity.FromString('*')) ), ( "templates", ClassTypeInfo(OrderedDict([ ( "name", StringTypeInfo(min_length=1) ), ( "description", StringTypeInfo(min_length=0, arity=Arity.FromString('?')) ), ( "types", StringTypeInfo(min_length=1, arity=Arity.FromString('+')) ) ]), require_exact_match=True, arity=Arity.FromString('*')) ), ( "featurizer_is_a_template", BoolTypeInfo(arity=Arity.FromString('?')) ), ( "input_description", StringTypeInfo(min_length=0, arity=Arity.FromString('?')) ), ( "output_description", StringTypeInfo(min_length=0, arity=Arity.FromString('?')) ), ( "is_input_a_template", BoolTypeInfo(arity=Arity.FromString('?')) ), ( "is_output_a_template", BoolTypeInfo(arity=Arity.FromString('?')) ), ( "type_mappings", ClassTypeInfo(OrderedDict([ ( "description", StringTypeInfo(min_length=0, arity=Arity.FromString('?')) ), ( "input_type", StringTypeInfo(min_length=1) ), ( "is_input_optional", BoolTypeInfo(arity=Arity.FromString('?')) ), ( "output_type", StringTypeInfo(min_length=1) ), ( "is_output_optional", BoolTypeInfo(arity=Arity.FromString('?')) ) ]), require_exact_match=True, arity=Arity.FromString('*')) ) ]), require_exact_match=True, arity=Arity.FromString('+')))

_Param_TypeInfo_Contents                                                    = OrderedDict([("type", GenericTypeInfo()), ("name", GenericTypeInfo()), ("description", GenericTypeInfo(arity=Arity.FromString('?'))), ("is_optional", GenericTypeInfo(arity=Arity.FromString('?')))])
_custom_structs_TypeInfo_Contents                                           = OrderedDict([("name", GenericTypeInfo()), ("description", GenericTypeInfo(arity=Arity.FromString('?'))), ("members", GenericTypeInfo(arity=Arity.FromString('+')))])
_custom_enums_TypeInfo_Contents                                             = OrderedDict([("name", GenericTypeInfo()), ("description", GenericTypeInfo(arity=Arity.FromString('?'))), ("starting_index", GenericTypeInfo(arity=Arity.FromString('?'))), ("underlying_type", GenericTypeInfo(arity=Arity.FromString('?'))), ("values", GenericTypeInfo(arity=Arity.FromString('+'))), ("integer_values", GenericTypeInfo(arity=Arity.FromString('*')))])
_featurizers_TypeInfo_Contents                                              = OrderedDict([("name", GenericTypeInfo()), ("estimator_name", GenericTypeInfo()), ("release_version", GenericTypeInfo()), ("updated_version", GenericTypeInfo(arity=Arity.FromString('?'))), ("deprecated_version", GenericTypeInfo(arity=Arity.FromString('?'))), ("num_output_columns", GenericTypeInfo()), ("description", GenericTypeInfo(arity=Arity.FromString('?'))), ("status", GenericTypeInfo(arity=Arity.FromString('?'))), ("has_dynamic_output", GenericTypeInfo(arity=Arity.FromString('?'))), ("transformer_maintains_state", GenericTypeInfo(arity=Arity.FromString('?'))), ("creates_annotations", GenericTypeInfo(arity=Arity.FromString('?'))), ("custom_structs", GenericTypeInfo(arity=Arity.FromString('*'))), ("custom_enums", GenericTypeInfo(arity=Arity.FromString('*'))), ("configuration_params", GenericTypeInfo(arity=Arity.FromString('*'))), ("templates", GenericTypeInfo(arity=Arity.FromString('*'))), ("featurizer_is_a_template", GenericTypeInfo(arity=Arity.FromString('?'))), ("input_description", GenericTypeInfo(arity=Arity.FromString('?'))), ("output_description", GenericTypeInfo(arity=Arity.FromString('?'))), ("is_input_a_template", GenericTypeInfo(arity=Arity.FromString('?'))), ("is_output_a_template", GenericTypeInfo(arity=Arity.FromString('?'))), ("type_mappings", GenericTypeInfo(arity=Arity.FromString('*')))])
_featurizers_templates_TypeInfo_Contents                                    = OrderedDict([("name", GenericTypeInfo()), ("description", GenericTypeInfo(arity=Arity.FromString('?'))), ("types", GenericTypeInfo(arity=Arity.FromString('+')))])
_featurizers_type_mappings_TypeInfo_Contents                                = OrderedDict([("description", GenericTypeInfo(arity=Arity.FromString('?'))), ("input_type", GenericTypeInfo()), ("is_input_optional", GenericTypeInfo(arity=Arity.FromString('?'))), ("output_type", GenericTypeInfo()), ("is_output_optional", GenericTypeInfo(arity=Arity.FromString('?')))])

_Description_TypeInfo                                                       = StringTypeInfo(min_length=0, arity=Arity.FromString('?'))
_Param_TypeInfo                                                             = AnyOfTypeInfo([ClassTypeInfo(_Param_TypeInfo_Contents, require_exact_match=False), DictTypeInfo(_Param_TypeInfo_Contents, require_exact_match=False)])
_Param_type_TypeInfo                                                        = StringTypeInfo(min_length=1)
_Param_name_TypeInfo                                                        = StringTypeInfo(min_length=1)
_Param_is_optional_TypeInfo                                                 = BoolTypeInfo(arity=Arity.FromString('?'))
_custom_structs_TypeInfo                                                    = AnyOfTypeInfo([ClassTypeInfo(_custom_structs_TypeInfo_Contents, require_exact_match=False), DictTypeInfo(_custom_structs_TypeInfo_Contents, require_exact_match=False)], arity=Arity.FromString('*'))
_custom_structs_name_TypeInfo                                               = StringTypeInfo(min_length=1)
_custom_structs_members_TypeInfo                                            = AnyOfTypeInfo([ClassTypeInfo(_Param_TypeInfo_Contents, require_exact_match=False), DictTypeInfo(_Param_TypeInfo_Contents, require_exact_match=False)], arity=Arity.FromString('+'))
_custom_enums_TypeInfo                                                      = AnyOfTypeInfo([ClassTypeInfo(_custom_enums_TypeInfo_Contents, require_exact_match=False), DictTypeInfo(_custom_enums_TypeInfo_Contents, require_exact_match=False)], arity=Arity.FromString('*'))
_custom_enums_name_TypeInfo                                                 = StringTypeInfo(min_length=1)
_custom_enums_starting_index_TypeInfo                                       = IntTypeInfo(min=0, arity=Arity.FromString('?'))
_custom_enums_underlying_type_TypeInfo                                      = StringTypeInfo(min_length=1, arity=Arity.FromString('?'))
_custom_enums_values_TypeInfo                                               = StringTypeInfo(min_length=1, arity=Arity.FromString('+'))
_custom_enums_integer_values_TypeInfo                                       = IntTypeInfo(arity=Arity.FromString('*'))
_featurizers_TypeInfo                                                       = AnyOfTypeInfo([ClassTypeInfo(_featurizers_TypeInfo_Contents, require_exact_match=False), DictTypeInfo(_featurizers_TypeInfo_Contents, require_exact_match=False)], arity=Arity.FromString('+'))
_featurizers_name_TypeInfo                                                  = StringTypeInfo(min_length=1)
_featurizers_estimator_name_TypeInfo                                        = StringTypeInfo(min_length=1)
_featurizers_release_version_TypeInfo                                       = StringTypeInfo(min_length=1)
_featurizers_updated_version_TypeInfo                                       = StringTypeInfo(min_length=1, arity=Arity.FromString('?'))
_featurizers_deprecated_version_TypeInfo                                    = StringTypeInfo(min_length=1, arity=Arity.FromString('?'))
_featurizers_num_output_columns_TypeInfo                                    = IntTypeInfo(min=1)
_featurizers_status_TypeInfo                                                = EnumTypeInfo([ 'Pending', 'External', 'Available', ], arity=Arity.FromString('?'))
_featurizers_has_dynamic_output_TypeInfo                                    = BoolTypeInfo(arity=Arity.FromString('?'))
_featurizers_transformer_maintains_state_TypeInfo                           = BoolTypeInfo(arity=Arity.FromString('?'))
_featurizers_creates_annotations_TypeInfo                                   = BoolTypeInfo(arity=Arity.FromString('?'))
_featurizers_configuration_params_TypeInfo                                  = AnyOfTypeInfo([ClassTypeInfo(_Param_TypeInfo_Contents, require_exact_match=False), DictTypeInfo(_Param_TypeInfo_Contents, require_exact_match=False)], arity=Arity.FromString('*'))
_featurizers_templates_TypeInfo                                             = AnyOfTypeInfo([ClassTypeInfo(_featurizers_templates_TypeInfo_Contents, require_exact_match=False), DictTypeInfo(_featurizers_templates_TypeInfo_Contents, require_exact_match=False)], arity=Arity.FromString('*'))
_featurizers_templates_name_TypeInfo                                        = StringTypeInfo(min_length=1)
_featurizers_templates_types_TypeInfo                                       = StringTypeInfo(min_length=1, arity=Arity.FromString('+'))
_featurizers_featurizer_is_a_template_TypeInfo                              = BoolTypeInfo(arity=Arity.FromString('?'))
_featurizers_is_input_a_template_TypeInfo                                   = BoolTypeInfo(arity=Arity.FromString('?'))
_featurizers_is_output_a_template_TypeInfo                                  = BoolTypeInfo(arity=Arity.FromString('?'))
_featurizers_type_mappings_TypeInfo                                         = AnyOfTypeInfo([ClassTypeInfo(_featurizers_type_mappings_TypeInfo_Contents, require_exact_match=False), DictTypeInfo(_featurizers_type_mappings_TypeInfo_Contents, require_exact_match=False)], arity=Arity.FromString('*'))
_featurizers_type_mappings_input_type_TypeInfo                              = StringTypeInfo(min_length=1)
_featurizers_type_mappings_is_input_optional_TypeInfo                       = BoolTypeInfo(arity=Arity.FromString('?'))
_featurizers_type_mappings_output_type_TypeInfo                             = StringTypeInfo(min_length=1)
_featurizers_type_mappings_is_output_optional_TypeInfo                      = BoolTypeInfo(arity=Arity.FromString('?'))

# ----------------------------------------------------------------------
# |
# |  Deserializer
# |
# ----------------------------------------------------------------------
class Deserializer(object):

    # ----------------------------------------------------------------------
    @classmethod
    def Description(cls, item):
        if item in [DoesNotExist, None]:
            _Description_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._Description_Item(item)

        _Description_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def Param(cls, item, always_include_optional, process_additional_data):
        if item in [DoesNotExist, None]:
            _Param_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._Param_Item(item, always_include_optional, process_additional_data)

        _Param_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def Param_type(cls, item):
        if item in [DoesNotExist, None]:
            _Param_type_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._Param_type_Item(item)

        _Param_type_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def Param_name(cls, item):
        if item in [DoesNotExist, None]:
            _Param_name_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._Param_name_Item(item)

        _Param_name_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def Param_description(cls, item):
        return cls.Description(item)

    # ----------------------------------------------------------------------
    @classmethod
    def Param_is_optional(cls, item):
        if item in [DoesNotExist, None]:
            _Param_is_optional_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._Param_is_optional_Item(item)

        _Param_is_optional_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def custom_structs(cls, items, always_include_optional, process_additional_data):
        if items in [DoesNotExist, None, []]:
            _custom_structs_TypeInfo.ValidateArity(None)
            return DoesNotExist

        results = []

        for this_index, this_item in enumerate(items or []):
            try:
                results.append(cls._custom_structs_Item(this_item, always_include_optional, process_additional_data))
            except:
                _DecorateActiveException("Index {}".format(this_index))

        _custom_structs_TypeInfo.ValidateArity(results)

        return results

    # ----------------------------------------------------------------------
    @classmethod
    def custom_structs_name(cls, item):
        if item in [DoesNotExist, None]:
            _custom_structs_name_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._custom_structs_name_Item(item)

        _custom_structs_name_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def custom_structs_description(cls, item):
        return cls.Description(item)

    # ----------------------------------------------------------------------
    @classmethod
    def custom_structs_members(cls, items, always_include_optional, process_additional_data):
        if items in [DoesNotExist, None, []]:
            _custom_structs_members_TypeInfo.ValidateArity(None)
            return DoesNotExist

        results = []

        for this_index, this_item in enumerate(items or []):
            try:
                results.append(cls._custom_structs_members_Item(this_item, always_include_optional, process_additional_data))
            except:
                _DecorateActiveException("Index {}".format(this_index))

        _custom_structs_members_TypeInfo.ValidateArity(results)

        return results

    # ----------------------------------------------------------------------
    @classmethod
    def custom_enums(cls, items, always_include_optional, process_additional_data):
        if items in [DoesNotExist, None, []]:
            _custom_enums_TypeInfo.ValidateArity(None)
            return DoesNotExist

        results = []

        for this_index, this_item in enumerate(items or []):
            try:
                results.append(cls._custom_enums_Item(this_item, always_include_optional, process_additional_data))
            except:
                _DecorateActiveException("Index {}".format(this_index))

        _custom_enums_TypeInfo.ValidateArity(results)

        return results

    # ----------------------------------------------------------------------
    @classmethod
    def custom_enums_name(cls, item):
        if item in [DoesNotExist, None]:
            _custom_enums_name_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._custom_enums_name_Item(item)

        _custom_enums_name_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def custom_enums_description(cls, item):
        return cls.Description(item)

    # ----------------------------------------------------------------------
    @classmethod
    def custom_enums_starting_index(cls, item):
        if item in [DoesNotExist, None]:
            _custom_enums_starting_index_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._custom_enums_starting_index_Item(item)

        _custom_enums_starting_index_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def custom_enums_underlying_type(cls, item):
        if item in [DoesNotExist, None]:
            _custom_enums_underlying_type_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._custom_enums_underlying_type_Item(item)

        _custom_enums_underlying_type_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def custom_enums_values(cls, items):
        if items in [DoesNotExist, None, []]:
            _custom_enums_values_TypeInfo.ValidateArity(None)
            return DoesNotExist

        results = []

        for this_index, this_item in enumerate(items or []):
            try:
                results.append(cls._custom_enums_values_Item(this_item))
            except:
                _DecorateActiveException("Index {}".format(this_index))

        _custom_enums_values_TypeInfo.ValidateArity(results)

        return results

    # ----------------------------------------------------------------------
    @classmethod
    def custom_enums_integer_values(cls, items):
        if items in [DoesNotExist, None, []]:
            _custom_enums_integer_values_TypeInfo.ValidateArity(None)
            return DoesNotExist

        results = []

        for this_index, this_item in enumerate(items or []):
            try:
                results.append(cls._custom_enums_integer_values_Item(this_item))
            except:
                _DecorateActiveException("Index {}".format(this_index))

        _custom_enums_integer_values_TypeInfo.ValidateArity(results)

        return results

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers(cls, items, always_include_optional, process_additional_data):
        if items in [DoesNotExist, None, []]:
            _featurizers_TypeInfo.ValidateArity(None)
            return DoesNotExist

        results = []

        for this_index, this_item in enumerate(items or []):
            try:
                results.append(cls._featurizers_Item(this_item, always_include_optional, process_additional_data))
            except:
                _DecorateActiveException("Index {}".format(this_index))

        _featurizers_TypeInfo.ValidateArity(results)

        return results

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_name(cls, item):
        if item in [DoesNotExist, None]:
            _featurizers_name_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._featurizers_name_Item(item)

        _featurizers_name_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_estimator_name(cls, item):
        if item in [DoesNotExist, None]:
            _featurizers_estimator_name_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._featurizers_estimator_name_Item(item)

        _featurizers_estimator_name_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_release_version(cls, item):
        if item in [DoesNotExist, None]:
            _featurizers_release_version_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._featurizers_release_version_Item(item)

        _featurizers_release_version_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_updated_version(cls, item):
        if item in [DoesNotExist, None]:
            _featurizers_updated_version_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._featurizers_updated_version_Item(item)

        _featurizers_updated_version_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_deprecated_version(cls, item):
        if item in [DoesNotExist, None]:
            _featurizers_deprecated_version_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._featurizers_deprecated_version_Item(item)

        _featurizers_deprecated_version_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_num_output_columns(cls, item):
        if item in [DoesNotExist, None]:
            _featurizers_num_output_columns_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._featurizers_num_output_columns_Item(item)

        _featurizers_num_output_columns_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_description(cls, item):
        return cls.Description(item)

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_status(cls, item):
        if item in [DoesNotExist, None]:
            _featurizers_status_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._featurizers_status_Item(item)

        _featurizers_status_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_has_dynamic_output(cls, item):
        if item in [DoesNotExist, None]:
            _featurizers_has_dynamic_output_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._featurizers_has_dynamic_output_Item(item)

        _featurizers_has_dynamic_output_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_transformer_maintains_state(cls, item):
        if item in [DoesNotExist, None]:
            _featurizers_transformer_maintains_state_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._featurizers_transformer_maintains_state_Item(item)

        _featurizers_transformer_maintains_state_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_creates_annotations(cls, item):
        if item in [DoesNotExist, None]:
            _featurizers_creates_annotations_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._featurizers_creates_annotations_Item(item)

        _featurizers_creates_annotations_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_custom_structs(cls, items, always_include_optional, process_additional_data):
        return cls.custom_structs(items, always_include_optional, process_additional_data)

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_custom_enums(cls, items, always_include_optional, process_additional_data):
        return cls.custom_enums(items, always_include_optional, process_additional_data)

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_configuration_params(cls, items, always_include_optional, process_additional_data):
        if items in [DoesNotExist, None, []]:
            _featurizers_configuration_params_TypeInfo.ValidateArity(None)
            return DoesNotExist

        results = []

        for this_index, this_item in enumerate(items or []):
            try:
                results.append(cls._featurizers_configuration_params_Item(this_item, always_include_optional, process_additional_data))
            except:
                _DecorateActiveException("Index {}".format(this_index))

        _featurizers_configuration_params_TypeInfo.ValidateArity(results)

        return results

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_templates(cls, items, always_include_optional, process_additional_data):
        if items in [DoesNotExist, None, []]:
            _featurizers_templates_TypeInfo.ValidateArity(None)
            return DoesNotExist

        results = []

        for this_index, this_item in enumerate(items or []):
            try:
                results.append(cls._featurizers_templates_Item(this_item, always_include_optional, process_additional_data))
            except:
                _DecorateActiveException("Index {}".format(this_index))

        _featurizers_templates_TypeInfo.ValidateArity(results)

        return results

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_templates_name(cls, item):
        if item in [DoesNotExist, None]:
            _featurizers_templates_name_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._featurizers_templates_name_Item(item)

        _featurizers_templates_name_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_templates_description(cls, item):
        return cls.Description(item)

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_templates_types(cls, items):
        if items in [DoesNotExist, None, []]:
            _featurizers_templates_types_TypeInfo.ValidateArity(None)
            return DoesNotExist

        results = []

        for this_index, this_item in enumerate(items or []):
            try:
                results.append(cls._featurizers_templates_types_Item(this_item))
            except:
                _DecorateActiveException("Index {}".format(this_index))

        _featurizers_templates_types_TypeInfo.ValidateArity(results)

        return results

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_featurizer_is_a_template(cls, item):
        if item in [DoesNotExist, None]:
            _featurizers_featurizer_is_a_template_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._featurizers_featurizer_is_a_template_Item(item)

        _featurizers_featurizer_is_a_template_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_input_description(cls, item):
        return cls.Description(item)

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_output_description(cls, item):
        return cls.Description(item)

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_is_input_a_template(cls, item):
        if item in [DoesNotExist, None]:
            _featurizers_is_input_a_template_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._featurizers_is_input_a_template_Item(item)

        _featurizers_is_input_a_template_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_is_output_a_template(cls, item):
        if item in [DoesNotExist, None]:
            _featurizers_is_output_a_template_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._featurizers_is_output_a_template_Item(item)

        _featurizers_is_output_a_template_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_type_mappings(cls, items, always_include_optional, process_additional_data):
        if items in [DoesNotExist, None, []]:
            _featurizers_type_mappings_TypeInfo.ValidateArity(None)
            return DoesNotExist

        results = []

        for this_index, this_item in enumerate(items or []):
            try:
                results.append(cls._featurizers_type_mappings_Item(this_item, always_include_optional, process_additional_data))
            except:
                _DecorateActiveException("Index {}".format(this_index))

        _featurizers_type_mappings_TypeInfo.ValidateArity(results)

        return results

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_type_mappings_description(cls, item):
        return cls.Description(item)

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_type_mappings_input_type(cls, item):
        if item in [DoesNotExist, None]:
            _featurizers_type_mappings_input_type_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._featurizers_type_mappings_input_type_Item(item)

        _featurizers_type_mappings_input_type_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_type_mappings_is_input_optional(cls, item):
        if item in [DoesNotExist, None]:
            _featurizers_type_mappings_is_input_optional_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._featurizers_type_mappings_is_input_optional_Item(item)

        _featurizers_type_mappings_is_input_optional_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_type_mappings_output_type(cls, item):
        if item in [DoesNotExist, None]:
            _featurizers_type_mappings_output_type_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._featurizers_type_mappings_output_type_Item(item)

        _featurizers_type_mappings_output_type_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def featurizers_type_mappings_is_output_optional(cls, item):
        if item in [DoesNotExist, None]:
            _featurizers_type_mappings_is_output_optional_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._featurizers_type_mappings_is_output_optional_Item(item)

        _featurizers_type_mappings_is_output_optional_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    @classmethod
    def _Description_Item(cls, item):
        return YamlSerialization.DeserializeItem(_Description_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Param_Item(cls, item, always_include_optional, process_additional_data):
        attributes = OrderedDict()

        # type
        try:
            attributes["type"] = cls.Param_type(
                cls._GetPythonAttribute(
                    item,
                    "type",
                    is_optional=False,
                ),
            )
        except:
            _DecorateActiveException("type")

        # name
        try:
            attributes["name"] = cls.Param_name(
                cls._GetPythonAttribute(
                    item,
                    "name",
                    is_optional=False,
                ),
            )
        except:
            _DecorateActiveException("name")

        # is_optional
        try:
            cls._ApplyOptionalAttribute(item, "is_optional", attributes, cls.Param_is_optional, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_Param_is_optional_TypeInfo, "false"))
        except:
            _DecorateActiveException("is_optional")

        result = _CreatePythonObject(
            attributes=attributes,
        )

        # description
        try:
            cls._ApplyOptionalChild(item, "description", result, cls.Param_description, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_Description_TypeInfo, ""))
        except:
            _DecorateActiveException("description")

        # Additional data
        if process_additional_data:
            cls._ApplyAdditionalData(
                item,
                result,
                exclude_names={"type", "name", "description", "is_optional"},
            )

        _Param_TypeInfo.ValidateItem(
            result,
            recurse=False,
            require_exact_match=not process_additional_data,
        )

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def _Param_type_Item(cls, item):
        return YamlSerialization.DeserializeItem(_Param_type_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Param_name_Item(cls, item):
        return YamlSerialization.DeserializeItem(_Param_name_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Param_is_optional_Item(cls, item):
        return YamlSerialization.DeserializeItem(_Param_is_optional_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _custom_structs_Item(cls, item, always_include_optional, process_additional_data):
        attributes = OrderedDict()

        # name
        try:
            attributes["name"] = cls.custom_structs_name(
                cls._GetPythonAttribute(
                    item,
                    "name",
                    is_optional=False,
                ),
            )
        except:
            _DecorateActiveException("name")

        result = _CreatePythonObject(
            attributes=attributes,
        )

        # description
        try:
            cls._ApplyOptionalChild(item, "description", result, cls.custom_structs_description, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_Description_TypeInfo, ""))
        except:
            _DecorateActiveException("description")

        # members
        try:
            setattr(result, "members", cls.custom_structs_members(
                cls._GetPythonAttribute(
                    item,
                    "members",
                    is_optional=False,
                ),
                always_include_optional,
                process_additional_data

            )
            )
        except:
            _DecorateActiveException("members")

        # Additional data
        if process_additional_data:
            cls._ApplyAdditionalData(
                item,
                result,
                exclude_names={"name", "description", "members"},
            )

        _custom_structs_TypeInfo.ValidateItem(
            result,
            recurse=False,
            require_exact_match=not process_additional_data,
        )

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def _custom_structs_name_Item(cls, item):
        return YamlSerialization.DeserializeItem(_custom_structs_name_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _custom_structs_members_Item(cls, item, always_include_optional, process_additional_data):
        attributes = OrderedDict()

        # type
        try:
            attributes["type"] = cls.Param_type(
                cls._GetPythonAttribute(
                    item,
                    "type",
                    is_optional=False,
                ),
            )
        except:
            _DecorateActiveException("type")

        # name
        try:
            attributes["name"] = cls.Param_name(
                cls._GetPythonAttribute(
                    item,
                    "name",
                    is_optional=False,
                ),
            )
        except:
            _DecorateActiveException("name")

        # is_optional
        try:
            cls._ApplyOptionalAttribute(item, "is_optional", attributes, cls.Param_is_optional, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_Param_is_optional_TypeInfo, "false"))
        except:
            _DecorateActiveException("is_optional")

        result = _CreatePythonObject(
            attributes=attributes,
        )

        # description
        try:
            cls._ApplyOptionalChild(item, "description", result, cls.Param_description, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_Description_TypeInfo, ""))
        except:
            _DecorateActiveException("description")

        # Additional data
        if process_additional_data:
            cls._ApplyAdditionalData(
                item,
                result,
                exclude_names={"type", "name", "description", "is_optional"},
            )

        _custom_structs_members_TypeInfo.ValidateItem(
            result,
            recurse=False,
            require_exact_match=not process_additional_data,
        )

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def _custom_enums_Item(cls, item, always_include_optional, process_additional_data):
        attributes = OrderedDict()

        # name
        try:
            attributes["name"] = cls.custom_enums_name(
                cls._GetPythonAttribute(
                    item,
                    "name",
                    is_optional=False,
                ),
            )
        except:
            _DecorateActiveException("name")

        # starting_index
        try:
            cls._ApplyOptionalAttribute(item, "starting_index", attributes, cls.custom_enums_starting_index, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_custom_enums_starting_index_TypeInfo, "1"))
        except:
            _DecorateActiveException("starting_index")

        # underlying_type
        try:
            cls._ApplyOptionalAttribute(item, "underlying_type", attributes, cls.custom_enums_underlying_type, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_custom_enums_underlying_type_TypeInfo, "uint32"))
        except:
            _DecorateActiveException("underlying_type")

        result = _CreatePythonObject(
            attributes=attributes,
        )

        # description
        try:
            cls._ApplyOptionalChild(item, "description", result, cls.custom_enums_description, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_Description_TypeInfo, ""))
        except:
            _DecorateActiveException("description")

        # values
        try:
            setattr(result, "values", cls.custom_enums_values(
                cls._GetPythonAttribute(
                    item,
                    "values",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("values")

        # integer_values
        try:
            cls._ApplyOptionalChildren(item, "integer_values", result, cls.custom_enums_integer_values, always_include_optional)
        except:
            _DecorateActiveException("integer_values")

        # Additional data
        if process_additional_data:
            cls._ApplyAdditionalData(
                item,
                result,
                exclude_names={"name", "description", "starting_index", "underlying_type", "values", "integer_values"},
            )

        _custom_enums_TypeInfo.ValidateItem(
            result,
            recurse=False,
            require_exact_match=not process_additional_data,
        )

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def _custom_enums_name_Item(cls, item):
        return YamlSerialization.DeserializeItem(_custom_enums_name_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _custom_enums_starting_index_Item(cls, item):
        return YamlSerialization.DeserializeItem(_custom_enums_starting_index_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _custom_enums_underlying_type_Item(cls, item):
        return YamlSerialization.DeserializeItem(_custom_enums_underlying_type_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _custom_enums_values_Item(cls, item):
        return YamlSerialization.DeserializeItem(_custom_enums_values_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _custom_enums_integer_values_Item(cls, item):
        return YamlSerialization.DeserializeItem(_custom_enums_integer_values_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_Item(cls, item, always_include_optional, process_additional_data):
        attributes = OrderedDict()

        # name
        try:
            attributes["name"] = cls.featurizers_name(
                cls._GetPythonAttribute(
                    item,
                    "name",
                    is_optional=False,
                ),
            )
        except:
            _DecorateActiveException("name")

        # estimator_name
        try:
            attributes["estimator_name"] = cls.featurizers_estimator_name(
                cls._GetPythonAttribute(
                    item,
                    "estimator_name",
                    is_optional=False,
                ),
            )
        except:
            _DecorateActiveException("estimator_name")

        # release_version
        try:
            attributes["release_version"] = cls.featurizers_release_version(
                cls._GetPythonAttribute(
                    item,
                    "release_version",
                    is_optional=False,
                ),
            )
        except:
            _DecorateActiveException("release_version")

        # updated_version
        try:
            cls._ApplyOptionalAttribute(item, "updated_version", attributes, cls.featurizers_updated_version, always_include_optional)
        except:
            _DecorateActiveException("updated_version")

        # deprecated_version
        try:
            cls._ApplyOptionalAttribute(item, "deprecated_version", attributes, cls.featurizers_deprecated_version, always_include_optional)
        except:
            _DecorateActiveException("deprecated_version")

        # num_output_columns
        try:
            attributes["num_output_columns"] = cls.featurizers_num_output_columns(
                cls._GetPythonAttribute(
                    item,
                    "num_output_columns",
                    is_optional=False,
                ),
            )
        except:
            _DecorateActiveException("num_output_columns")

        # status
        try:
            cls._ApplyOptionalAttribute(item, "status", attributes, cls.featurizers_status, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_featurizers_status_TypeInfo, "Available"))
        except:
            _DecorateActiveException("status")

        # has_dynamic_output
        try:
            cls._ApplyOptionalAttribute(item, "has_dynamic_output", attributes, cls.featurizers_has_dynamic_output, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_featurizers_has_dynamic_output_TypeInfo, "false"))
        except:
            _DecorateActiveException("has_dynamic_output")

        # transformer_maintains_state
        try:
            cls._ApplyOptionalAttribute(item, "transformer_maintains_state", attributes, cls.featurizers_transformer_maintains_state, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_featurizers_transformer_maintains_state_TypeInfo, "false"))
        except:
            _DecorateActiveException("transformer_maintains_state")

        # creates_annotations
        try:
            cls._ApplyOptionalAttribute(item, "creates_annotations", attributes, cls.featurizers_creates_annotations, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_featurizers_creates_annotations_TypeInfo, "true"))
        except:
            _DecorateActiveException("creates_annotations")

        # is_input_a_template
        try:
            cls._ApplyOptionalAttribute(item, "is_input_a_template", attributes, cls.featurizers_is_input_a_template, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_featurizers_is_input_a_template_TypeInfo, "true"))
        except:
            _DecorateActiveException("is_input_a_template")

        # is_output_a_template
        try:
            cls._ApplyOptionalAttribute(item, "is_output_a_template", attributes, cls.featurizers_is_output_a_template, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_featurizers_is_output_a_template_TypeInfo, "false"))
        except:
            _DecorateActiveException("is_output_a_template")

        result = _CreatePythonObject(
            attributes=attributes,
        )

        # description
        try:
            cls._ApplyOptionalChild(item, "description", result, cls.featurizers_description, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_Description_TypeInfo, ""))
        except:
            _DecorateActiveException("description")

        # custom_structs
        try:
            cls._ApplyOptionalChildren(item, "custom_structs", result, lambda value: cls.featurizers_custom_structs(value, always_include_optional, process_additional_data), always_include_optional)
        except:
            _DecorateActiveException("custom_structs")

        # custom_enums
        try:
            cls._ApplyOptionalChildren(item, "custom_enums", result, lambda value: cls.featurizers_custom_enums(value, always_include_optional, process_additional_data), always_include_optional)
        except:
            _DecorateActiveException("custom_enums")

        # configuration_params
        try:
            cls._ApplyOptionalChildren(item, "configuration_params", result, lambda value: cls.featurizers_configuration_params(value, always_include_optional, process_additional_data), always_include_optional)
        except:
            _DecorateActiveException("configuration_params")

        # templates
        try:
            cls._ApplyOptionalChildren(item, "templates", result, lambda value: cls.featurizers_templates(value, always_include_optional, process_additional_data), always_include_optional)
        except:
            _DecorateActiveException("templates")

        # featurizer_is_a_template
        try:
            cls._ApplyOptionalChild(item, "featurizer_is_a_template", result, cls.featurizers_featurizer_is_a_template, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_featurizers_featurizer_is_a_template_TypeInfo, "false"))
        except:
            _DecorateActiveException("featurizer_is_a_template")

        # input_description
        try:
            cls._ApplyOptionalChild(item, "input_description", result, cls.featurizers_input_description, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_Description_TypeInfo, ""))
        except:
            _DecorateActiveException("input_description")

        # output_description
        try:
            cls._ApplyOptionalChild(item, "output_description", result, cls.featurizers_output_description, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_Description_TypeInfo, ""))
        except:
            _DecorateActiveException("output_description")

        # type_mappings
        try:
            cls._ApplyOptionalChildren(item, "type_mappings", result, lambda value: cls.featurizers_type_mappings(value, always_include_optional, process_additional_data), always_include_optional)
        except:
            _DecorateActiveException("type_mappings")

        # Additional data
        if process_additional_data:
            cls._ApplyAdditionalData(
                item,
                result,
                exclude_names={"name", "estimator_name", "release_version", "updated_version", "deprecated_version", "num_output_columns", "description", "status", "has_dynamic_output", "transformer_maintains_state", "creates_annotations", "custom_structs", "custom_enums", "configuration_params", "templates", "featurizer_is_a_template", "input_description", "output_description", "is_input_a_template", "is_output_a_template", "type_mappings"},
            )

        _featurizers_TypeInfo.ValidateItem(
            result,
            recurse=False,
            require_exact_match=not process_additional_data,
        )

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_name_Item(cls, item):
        return YamlSerialization.DeserializeItem(_featurizers_name_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_estimator_name_Item(cls, item):
        return YamlSerialization.DeserializeItem(_featurizers_estimator_name_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_release_version_Item(cls, item):
        return YamlSerialization.DeserializeItem(_featurizers_release_version_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_updated_version_Item(cls, item):
        return YamlSerialization.DeserializeItem(_featurizers_updated_version_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_deprecated_version_Item(cls, item):
        return YamlSerialization.DeserializeItem(_featurizers_deprecated_version_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_num_output_columns_Item(cls, item):
        return YamlSerialization.DeserializeItem(_featurizers_num_output_columns_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_status_Item(cls, item):
        return YamlSerialization.DeserializeItem(_featurizers_status_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_has_dynamic_output_Item(cls, item):
        return YamlSerialization.DeserializeItem(_featurizers_has_dynamic_output_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_transformer_maintains_state_Item(cls, item):
        return YamlSerialization.DeserializeItem(_featurizers_transformer_maintains_state_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_creates_annotations_Item(cls, item):
        return YamlSerialization.DeserializeItem(_featurizers_creates_annotations_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_configuration_params_Item(cls, item, always_include_optional, process_additional_data):
        attributes = OrderedDict()

        # type
        try:
            attributes["type"] = cls.Param_type(
                cls._GetPythonAttribute(
                    item,
                    "type",
                    is_optional=False,
                ),
            )
        except:
            _DecorateActiveException("type")

        # name
        try:
            attributes["name"] = cls.Param_name(
                cls._GetPythonAttribute(
                    item,
                    "name",
                    is_optional=False,
                ),
            )
        except:
            _DecorateActiveException("name")

        # is_optional
        try:
            cls._ApplyOptionalAttribute(item, "is_optional", attributes, cls.Param_is_optional, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_Param_is_optional_TypeInfo, "false"))
        except:
            _DecorateActiveException("is_optional")

        result = _CreatePythonObject(
            attributes=attributes,
        )

        # description
        try:
            cls._ApplyOptionalChild(item, "description", result, cls.Param_description, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_Description_TypeInfo, ""))
        except:
            _DecorateActiveException("description")

        # Additional data
        if process_additional_data:
            cls._ApplyAdditionalData(
                item,
                result,
                exclude_names={"type", "name", "description", "is_optional"},
            )

        _featurizers_configuration_params_TypeInfo.ValidateItem(
            result,
            recurse=False,
            require_exact_match=not process_additional_data,
        )

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_templates_Item(cls, item, always_include_optional, process_additional_data):
        attributes = OrderedDict()

        # name
        try:
            attributes["name"] = cls.featurizers_templates_name(
                cls._GetPythonAttribute(
                    item,
                    "name",
                    is_optional=False,
                ),
            )
        except:
            _DecorateActiveException("name")

        result = _CreatePythonObject(
            attributes=attributes,
        )

        # description
        try:
            cls._ApplyOptionalChild(item, "description", result, cls.featurizers_templates_description, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_Description_TypeInfo, ""))
        except:
            _DecorateActiveException("description")

        # types
        try:
            setattr(result, "types", cls.featurizers_templates_types(
                cls._GetPythonAttribute(
                    item,
                    "types",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("types")

        # Additional data
        if process_additional_data:
            cls._ApplyAdditionalData(
                item,
                result,
                exclude_names={"name", "description", "types"},
            )

        _featurizers_templates_TypeInfo.ValidateItem(
            result,
            recurse=False,
            require_exact_match=not process_additional_data,
        )

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_templates_name_Item(cls, item):
        return YamlSerialization.DeserializeItem(_featurizers_templates_name_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_templates_types_Item(cls, item):
        return YamlSerialization.DeserializeItem(_featurizers_templates_types_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_featurizer_is_a_template_Item(cls, item):
        return YamlSerialization.DeserializeItem(_featurizers_featurizer_is_a_template_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_is_input_a_template_Item(cls, item):
        return YamlSerialization.DeserializeItem(_featurizers_is_input_a_template_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_is_output_a_template_Item(cls, item):
        return YamlSerialization.DeserializeItem(_featurizers_is_output_a_template_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_type_mappings_Item(cls, item, always_include_optional, process_additional_data):
        attributes = OrderedDict()

        # input_type
        try:
            attributes["input_type"] = cls.featurizers_type_mappings_input_type(
                cls._GetPythonAttribute(
                    item,
                    "input_type",
                    is_optional=False,
                ),
            )
        except:
            _DecorateActiveException("input_type")

        # is_input_optional
        try:
            cls._ApplyOptionalAttribute(item, "is_input_optional", attributes, cls.featurizers_type_mappings_is_input_optional, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_featurizers_type_mappings_is_input_optional_TypeInfo, "false"))
        except:
            _DecorateActiveException("is_input_optional")

        # output_type
        try:
            attributes["output_type"] = cls.featurizers_type_mappings_output_type(
                cls._GetPythonAttribute(
                    item,
                    "output_type",
                    is_optional=False,
                ),
            )
        except:
            _DecorateActiveException("output_type")

        # is_output_optional
        try:
            cls._ApplyOptionalAttribute(item, "is_output_optional", attributes, cls.featurizers_type_mappings_is_output_optional, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_featurizers_type_mappings_is_output_optional_TypeInfo, "false"))
        except:
            _DecorateActiveException("is_output_optional")

        result = _CreatePythonObject(
            attributes=attributes,
        )

        # description
        try:
            cls._ApplyOptionalChild(item, "description", result, cls.featurizers_type_mappings_description, always_include_optional, default_value_func=lambda: StringSerialization.DeserializeItem(_Description_TypeInfo, ""))
        except:
            _DecorateActiveException("description")

        # Additional data
        if process_additional_data:
            cls._ApplyAdditionalData(
                item,
                result,
                exclude_names={"description", "input_type", "is_input_optional", "output_type", "is_output_optional"},
            )

        _featurizers_type_mappings_TypeInfo.ValidateItem(
            result,
            recurse=False,
            require_exact_match=not process_additional_data,
        )

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_type_mappings_input_type_Item(cls, item):
        return YamlSerialization.DeserializeItem(_featurizers_type_mappings_input_type_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_type_mappings_is_input_optional_Item(cls, item):
        return YamlSerialization.DeserializeItem(_featurizers_type_mappings_is_input_optional_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_type_mappings_output_type_Item(cls, item):
        return YamlSerialization.DeserializeItem(_featurizers_type_mappings_output_type_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _featurizers_type_mappings_is_output_optional_Item(cls, item):
        return YamlSerialization.DeserializeItem(_featurizers_type_mappings_is_output_optional_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    @classmethod
    def _ApplyOptionalChild(cls, item, attribute_name, dest, apply_func, always_include_optional, default_value_func=None):
        value = cls._GetPythonAttribute(
            item,
            attribute_name,
            is_optional=True,
        )

        if value is not DoesNotExist:
            value = apply_func(value)
            if value is not DoesNotExist:
                setattr(dest, attribute_name, value)
                return

        if default_value_func:
            setattr(dest, attribute_name, default_value_func())
            return

        if always_include_optional:
            setattr(dest, attribute_name, None)

    # ----------------------------------------------------------------------
    @classmethod
    def _ApplyOptionalChildren(cls, items, attribute_name, dest, apply_func, always_include_optional):
        value = cls._GetPythonAttribute(
            items,
            attribute_name,
            is_optional=True,
        )

        if value is not DoesNotExist:
            value = apply_func(value)
            if value is not DoesNotExist:
                setattr(dest, attribute_name, value)
                return

        # No default statement

        if always_include_optional:
            setattr(dest, attribute_name, [])

    # ----------------------------------------------------------------------
    @classmethod
    def _ApplyOptionalAttribute(cls, item, attribute_name, dest, apply_func, always_include_optional, default_value_func=None):
        value = cls._GetPythonAttribute(
            item,
            attribute_name,
            is_optional=True,
        )

        if value is not DoesNotExist:
            value = apply_func(value)
            if value is not DoesNotExist:
                dest[attribute_name] = value
                return

        if default_value_func:
            dest[attribute_name] = default_value_func()
            return

        if always_include_optional:
            dest[attribute_name] = None

    # ----------------------------------------------------------------------
    @classmethod
    def _ApplyAdditionalData(
        cls,
        source,
        dest,
        exclude_names,
    ):
        for name, child in [(k, v) for k, v in six.iteritems(source if isinstance(source, dict) else source.__dict__) if not k.startswith("_") and k not in exclude_names]:
            try:
                if isinstance(child, list):
                    children = []

                    for index, item in enumerate(child):
                        item_name = "Index {}".format(index)

                        try:
                            children.append(cls._CreateAdditionalDataItem(item_name, item))
                        except:
                            _DecorateActiveException(item_name)

                    setattr(dest, name, children)
                else:
                    setattr(dest, name, cls._CreateAdditionalDataItem(name, child))
            except:
                _DecorateActiveException(name)

    # ----------------------------------------------------------------------
    @classmethod
    def _CreateAdditionalDataItem(cls, name, source):
        # The following types should be returned directly without additional conversion
        if isinstance(source, (int, float, str, bool)):
            return source

        assert not isinstance(source, list), source

        if not isinstance(source, dict):
            source = source.__dict__

        source_attribute_names = source.get("_attribute_names", set())

        attributes = OrderedDict()
        items = OrderedDict()

        for k, v in six.iteritems(source):
            if k.startswith("_"):
                continue

            if k in source_attribute_names:
                attributes[k] = v
            else:
                items[k] = v

        if len(items) == 1 and next(six.iterkeys(items)) == source.get("_text_attribute_name", None):
            return _CreatePythonObject(
                attributes=attributes,
                **{"simple_value": source[source["_text_attribute_name"]], "_text_attribute_name": "simple_value"},
            )

        result = _CreatePythonObject(
            attributes=attributes,
        )

        for k, v in six.iteritems(items):
            try:
                if isinstance(v, list):
                    new_items = []

                    for index, child in enumerate(v):
                        try:
                            new_items.append(cls._CreateAdditionalDataItem("item", child))
                        except:
                            _DecorateActiveException("Index {}".format(index))

                    setattr(result, k, new_items)
                else:
                    new_item = cls._CreateAdditionalDataItem(k, v)

                    setattr(result, k, new_item)
            except:
                _DecorateActiveException(k)

        return result

    # ----------------------------------------------------------------------
    @staticmethod
    def _GetPythonAttribute(
        item,
        attribute_name,
        is_optional=False,
    ):
        if not isinstance(item, dict):
            item = item.__dict__

        value = item.get(attribute_name, DoesNotExist)
        if value is DoesNotExist and not is_optional:
            raise SerializeException("No items were found")

        return value


# ----------------------------------------------------------------------
class Object(object):
    def __init__(self):
        self._attribute_names = set()

    def __repr__(self):
        return CommonEnvironment.ObjectReprImpl(self)


# ----------------------------------------------------------------------
def _CreatePythonObject(
    attributes=None,
    **kwargs
):
    attributes = attributes or {}

    result = Object()

    for d in [attributes, kwargs]:
        for k, v in six.iteritems(d):
            setattr(result, k, v)

    for k in six.iterkeys(attributes):
        result._attribute_names.add(k)

    return result


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
def _DecorateActiveException(frame_desc):
    exception = sys.exc_info()[1]

    if not hasattr(exception, "stack"):
        setattr(exception, "stack", [])

    exception.stack.insert(0, frame_desc)

    # <The raise statement is not inside an except clause> pylint: disable = E0704
    raise


# ----------------------------------------------------------------------
def _ObjectToYaml(dumper, data):
    d = dict(data.__dict__)
    for k in list(six.iterkeys(d)):
        if k.startswith("_"):
            del d[k]

    return dumper.represent_dict(d)


yaml.add_representer(Object, _ObjectToYaml)
